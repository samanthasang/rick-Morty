{"ast":null,"code":"import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\n\nfunction isPointsEq() {\n  var a1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var a2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var isAlignPoint = arguments.length > 2 ? arguments[2] : undefined;\n\n  if (isAlignPoint) {\n    return a1[0] === a2[0];\n  }\n\n  return a1[0] === a2[0] && a1[1] === a2[1];\n}\n\nexport function getAlignPopupClassName(builtinPlacements, prefixCls, align, isAlignPoint) {\n  var points = align.points;\n  var placements = Object.keys(builtinPlacements);\n\n  for (var i = 0; i < placements.length; i += 1) {\n    var _builtinPlacements$pl;\n\n    var placement = placements[i];\n\n    if (isPointsEq((_builtinPlacements$pl = builtinPlacements[placement]) === null || _builtinPlacements$pl === void 0 ? void 0 : _builtinPlacements$pl.points, points, isAlignPoint)) {\n      return \"\".concat(prefixCls, \"-placement-\").concat(placement);\n    }\n  }\n\n  return '';\n}\n/** @deprecated We should not use this if we can refactor all deps */\n\nexport function getMotion(prefixCls, motion, animation, transitionName) {\n  if (motion) {\n    return motion;\n  }\n\n  if (animation) {\n    return {\n      motionName: \"\".concat(prefixCls, \"-\").concat(animation)\n    };\n  }\n\n  if (transitionName) {\n    return {\n      motionName: transitionName\n    };\n  }\n\n  return null;\n}\nexport function getWin(ele) {\n  return ele.ownerDocument.defaultView;\n}\n/**\n * Get all the scrollable parent elements of the element\n * @param ele       The element to be detected\n * @param areaOnly  Only return the parent which will cut visible area\n */\n\nexport function collectScroller(ele) {\n  var scrollerList = [];\n  var current = ele === null || ele === void 0 ? void 0 : ele.parentElement;\n  var scrollStyle = ['hidden', 'scroll', 'auto'];\n\n  while (current) {\n    var _getWin$getComputedSt = getWin(current).getComputedStyle(current),\n        overflowX = _getWin$getComputedSt.overflowX,\n        overflowY = _getWin$getComputedSt.overflowY;\n\n    if (scrollStyle.includes(overflowX) || scrollStyle.includes(overflowY)) {\n      scrollerList.push(current);\n    }\n\n    current = current.parentElement;\n  }\n\n  return scrollerList;\n}\nexport function toNum(num) {\n  return Number.isNaN(num) ? 1 : num;\n}\nexport function getVisibleArea(initArea, scrollerList) {\n  var visibleArea = _objectSpread({}, initArea);\n\n  (scrollerList || []).forEach(function (ele) {\n    if (ele instanceof HTMLBodyElement) {\n      return;\n    } // Skip if static position which will not affect visible area\n\n\n    var _getWin$getComputedSt2 = getWin(ele).getComputedStyle(ele),\n        position = _getWin$getComputedSt2.position;\n\n    if (position === 'static') {\n      return;\n    }\n\n    var eleRect = ele.getBoundingClientRect();\n    var eleOutHeight = ele.offsetHeight,\n        eleInnerHeight = ele.clientHeight,\n        eleOutWidth = ele.offsetWidth,\n        eleInnerWidth = ele.clientWidth;\n    var scaleX = toNum(Math.round(eleRect.width / eleOutWidth * 1000) / 1000);\n    var scaleY = toNum(Math.round(eleRect.height / eleOutHeight * 1000) / 1000);\n    var eleScrollWidth = (eleOutWidth - eleInnerWidth) * scaleX;\n    var eleScrollHeight = (eleOutHeight - eleInnerHeight) * scaleY;\n    var eleRight = eleRect.x + eleRect.width - eleScrollWidth;\n    var eleBottom = eleRect.y + eleRect.height - eleScrollHeight;\n    visibleArea.left = Math.max(visibleArea.left, eleRect.x);\n    visibleArea.top = Math.max(visibleArea.top, eleRect.y);\n    visibleArea.right = Math.min(visibleArea.right, eleRight);\n    visibleArea.bottom = Math.min(visibleArea.bottom, eleBottom);\n  });\n  return visibleArea;\n}","map":{"version":3,"sources":["/Users/luna/Desktop/Project/Git Project/rick-Morty/node_modules/@rc-component/trigger/es/util.js"],"names":["_objectSpread","isPointsEq","a1","arguments","length","undefined","a2","isAlignPoint","getAlignPopupClassName","builtinPlacements","prefixCls","align","points","placements","Object","keys","i","_builtinPlacements$pl","placement","concat","getMotion","motion","animation","transitionName","motionName","getWin","ele","ownerDocument","defaultView","collectScroller","scrollerList","current","parentElement","scrollStyle","_getWin$getComputedSt","getComputedStyle","overflowX","overflowY","includes","push","toNum","num","Number","isNaN","getVisibleArea","initArea","visibleArea","forEach","HTMLBodyElement","_getWin$getComputedSt2","position","eleRect","getBoundingClientRect","eleOutHeight","offsetHeight","eleInnerHeight","clientHeight","eleOutWidth","offsetWidth","eleInnerWidth","clientWidth","scaleX","Math","round","width","scaleY","height","eleScrollWidth","eleScrollHeight","eleRight","x","eleBottom","y","left","max","top","right","min","bottom"],"mappings":"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","sourcesContent":["import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nfunction isPointsEq() {\n  var a1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var a2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var isAlignPoint = arguments.length > 2 ? arguments[2] : undefined;\n  if (isAlignPoint) {\n    return a1[0] === a2[0];\n  }\n  return a1[0] === a2[0] && a1[1] === a2[1];\n}\nexport function getAlignPopupClassName(builtinPlacements, prefixCls, align, isAlignPoint) {\n  var points = align.points;\n  var placements = Object.keys(builtinPlacements);\n  for (var i = 0; i < placements.length; i += 1) {\n    var _builtinPlacements$pl;\n    var placement = placements[i];\n    if (isPointsEq((_builtinPlacements$pl = builtinPlacements[placement]) === null || _builtinPlacements$pl === void 0 ? void 0 : _builtinPlacements$pl.points, points, isAlignPoint)) {\n      return \"\".concat(prefixCls, \"-placement-\").concat(placement);\n    }\n  }\n  return '';\n}\n\n/** @deprecated We should not use this if we can refactor all deps */\nexport function getMotion(prefixCls, motion, animation, transitionName) {\n  if (motion) {\n    return motion;\n  }\n  if (animation) {\n    return {\n      motionName: \"\".concat(prefixCls, \"-\").concat(animation)\n    };\n  }\n  if (transitionName) {\n    return {\n      motionName: transitionName\n    };\n  }\n  return null;\n}\nexport function getWin(ele) {\n  return ele.ownerDocument.defaultView;\n}\n\n/**\n * Get all the scrollable parent elements of the element\n * @param ele       The element to be detected\n * @param areaOnly  Only return the parent which will cut visible area\n */\nexport function collectScroller(ele) {\n  var scrollerList = [];\n  var current = ele === null || ele === void 0 ? void 0 : ele.parentElement;\n  var scrollStyle = ['hidden', 'scroll', 'auto'];\n  while (current) {\n    var _getWin$getComputedSt = getWin(current).getComputedStyle(current),\n      overflowX = _getWin$getComputedSt.overflowX,\n      overflowY = _getWin$getComputedSt.overflowY;\n    if (scrollStyle.includes(overflowX) || scrollStyle.includes(overflowY)) {\n      scrollerList.push(current);\n    }\n    current = current.parentElement;\n  }\n  return scrollerList;\n}\nexport function toNum(num) {\n  return Number.isNaN(num) ? 1 : num;\n}\nexport function getVisibleArea(initArea, scrollerList) {\n  var visibleArea = _objectSpread({}, initArea);\n  (scrollerList || []).forEach(function (ele) {\n    if (ele instanceof HTMLBodyElement) {\n      return;\n    }\n\n    // Skip if static position which will not affect visible area\n    var _getWin$getComputedSt2 = getWin(ele).getComputedStyle(ele),\n      position = _getWin$getComputedSt2.position;\n    if (position === 'static') {\n      return;\n    }\n    var eleRect = ele.getBoundingClientRect();\n    var eleOutHeight = ele.offsetHeight,\n      eleInnerHeight = ele.clientHeight,\n      eleOutWidth = ele.offsetWidth,\n      eleInnerWidth = ele.clientWidth;\n    var scaleX = toNum(Math.round(eleRect.width / eleOutWidth * 1000) / 1000);\n    var scaleY = toNum(Math.round(eleRect.height / eleOutHeight * 1000) / 1000);\n    var eleScrollWidth = (eleOutWidth - eleInnerWidth) * scaleX;\n    var eleScrollHeight = (eleOutHeight - eleInnerHeight) * scaleY;\n    var eleRight = eleRect.x + eleRect.width - eleScrollWidth;\n    var eleBottom = eleRect.y + eleRect.height - eleScrollHeight;\n    visibleArea.left = Math.max(visibleArea.left, eleRect.x);\n    visibleArea.top = Math.max(visibleArea.top, eleRect.y);\n    visibleArea.right = Math.min(visibleArea.right, eleRight);\n    visibleArea.bottom = Math.min(visibleArea.bottom, eleBottom);\n  });\n  return visibleArea;\n}"]},"metadata":{},"sourceType":"module"}