{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { supportRef } from \"rc-util/es/ref\";\nimport * as React from 'react';\nvar ImmutableContext = /*#__PURE__*/React.createContext(0);\n/**\n * Get render update mark by `makeImmutable` root.\n * Do not deps on the return value as render times\n * but only use for `useMemo` or `useCallback` deps.\n */\n\nexport function useImmutableMark() {\n  return React.useContext(ImmutableContext);\n}\n/**\n * Wrapped Component will be marked as Immutable.\n * When Component parent trigger render,\n * it will notice children component (use with `responseImmutable`) node that parent has updated.\n\n * @param Component Passed Component\n * @param triggerRender Customize trigger `responseImmutable` children re-render logic. Default will always trigger re-render when this component re-render.\n */\n\nexport function makeImmutable(Component, shouldTriggerRender) {\n  var refAble = supportRef(Component);\n\n  var ImmutableComponent = function ImmutableComponent(props, ref) {\n    var refProps = refAble ? {\n      ref: ref\n    } : {};\n    var renderTimesRef = React.useRef(0);\n    var prevProps = React.useRef(props);\n\n    if ( // Always trigger re-render if not provide `notTriggerRender`\n    !shouldTriggerRender || shouldTriggerRender(prevProps.current, props)) {\n      renderTimesRef.current += 1;\n    }\n\n    prevProps.current = props;\n    return /*#__PURE__*/React.createElement(ImmutableContext.Provider, {\n      value: renderTimesRef.current\n    }, /*#__PURE__*/React.createElement(Component, _extends({}, props, refProps)));\n  };\n\n  if (process.env.NODE_ENV !== 'production') {\n    ImmutableComponent.displayName = \"ImmutableRoot(\".concat(Component.displayName || Component.name, \")\");\n  }\n\n  return refAble ? /*#__PURE__*/React.forwardRef(ImmutableComponent) : ImmutableComponent;\n}\n/**\n * Wrapped Component with `React.memo`.\n * But will rerender when parent with `makeImmutable` rerender.\n */\n\nexport function responseImmutable(Component, propsAreEqual) {\n  var refAble = supportRef(Component);\n\n  var ImmutableComponent = function ImmutableComponent(props, ref) {\n    var refProps = refAble ? {\n      ref: ref\n    } : {};\n    useImmutableMark();\n    return /*#__PURE__*/React.createElement(Component, _extends({}, props, refProps));\n  };\n\n  if (process.env.NODE_ENV !== 'production') {\n    ImmutableComponent.displayName = \"ImmutableResponse(\".concat(Component.displayName || Component.name, \")\");\n  }\n\n  return refAble ? /*#__PURE__*/React.memo( /*#__PURE__*/React.forwardRef(ImmutableComponent), propsAreEqual) : /*#__PURE__*/React.memo(ImmutableComponent, propsAreEqual);\n}","map":{"version":3,"sources":["/Users/luna/Desktop/Project/Git Project/rick-Morty/node_modules/@rc-component/context/es/Immutable.js"],"names":["_extends","supportRef","React","ImmutableContext","createContext","useImmutableMark","useContext","makeImmutable","Component","shouldTriggerRender","refAble","ImmutableComponent","props","ref","refProps","renderTimesRef","useRef","prevProps","current","createElement","Provider","value","process","env","NODE_ENV","displayName","concat","name","forwardRef","responseImmutable","propsAreEqual","memo"],"mappings":"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","sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { supportRef } from \"rc-util/es/ref\";\nimport * as React from 'react';\nvar ImmutableContext = /*#__PURE__*/React.createContext(0);\n\n/**\n * Get render update mark by `makeImmutable` root.\n * Do not deps on the return value as render times\n * but only use for `useMemo` or `useCallback` deps.\n */\nexport function useImmutableMark() {\n  return React.useContext(ImmutableContext);\n}\n/**\n * Wrapped Component will be marked as Immutable.\n * When Component parent trigger render,\n * it will notice children component (use with `responseImmutable`) node that parent has updated.\n\n * @param Component Passed Component\n * @param triggerRender Customize trigger `responseImmutable` children re-render logic. Default will always trigger re-render when this component re-render.\n */\n\nexport function makeImmutable(Component, shouldTriggerRender) {\n  var refAble = supportRef(Component);\n\n  var ImmutableComponent = function ImmutableComponent(props, ref) {\n    var refProps = refAble ? {\n      ref: ref\n    } : {};\n    var renderTimesRef = React.useRef(0);\n    var prevProps = React.useRef(props);\n\n    if ( // Always trigger re-render if not provide `notTriggerRender`\n    !shouldTriggerRender || shouldTriggerRender(prevProps.current, props)) {\n      renderTimesRef.current += 1;\n    }\n\n    prevProps.current = props;\n    return /*#__PURE__*/React.createElement(ImmutableContext.Provider, {\n      value: renderTimesRef.current\n    }, /*#__PURE__*/React.createElement(Component, _extends({}, props, refProps)));\n  };\n\n  if (process.env.NODE_ENV !== 'production') {\n    ImmutableComponent.displayName = \"ImmutableRoot(\".concat(Component.displayName || Component.name, \")\");\n  }\n\n  return refAble ? /*#__PURE__*/React.forwardRef(ImmutableComponent) : ImmutableComponent;\n}\n/**\n * Wrapped Component with `React.memo`.\n * But will rerender when parent with `makeImmutable` rerender.\n */\n\nexport function responseImmutable(Component, propsAreEqual) {\n  var refAble = supportRef(Component);\n\n  var ImmutableComponent = function ImmutableComponent(props, ref) {\n    var refProps = refAble ? {\n      ref: ref\n    } : {};\n    useImmutableMark();\n    return /*#__PURE__*/React.createElement(Component, _extends({}, props, refProps));\n  };\n\n  if (process.env.NODE_ENV !== 'production') {\n    ImmutableComponent.displayName = \"ImmutableResponse(\".concat(Component.displayName || Component.name, \")\");\n  }\n\n  return refAble ? /*#__PURE__*/React.memo( /*#__PURE__*/React.forwardRef(ImmutableComponent), propsAreEqual) : /*#__PURE__*/React.memo(ImmutableComponent, propsAreEqual);\n}"]},"metadata":{},"sourceType":"module"}