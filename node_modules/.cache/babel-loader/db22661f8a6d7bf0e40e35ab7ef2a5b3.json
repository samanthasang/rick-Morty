{"ast":null,"code":"import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport { isDOM } from \"rc-util/es/Dom/findDOMNode\";\nimport isVisible from \"rc-util/es/Dom/isVisible\";\nimport useEvent from \"rc-util/es/hooks/useEvent\";\nimport useLayoutEffect from \"rc-util/es/hooks/useLayoutEffect\";\nimport * as React from 'react';\nimport { collectScroller, getVisibleArea, getWin, toNum } from \"../util\";\n\nfunction splitPoints() {\n  var points = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  return [points[0], points[1]];\n}\n\nfunction getAlignPoint(rect, points) {\n  var topBottom = points[0];\n  var leftRight = points[1];\n  var x;\n  var y; // Top & Bottom\n\n  if (topBottom === 't') {\n    y = rect.y;\n  } else if (topBottom === 'b') {\n    y = rect.y + rect.height;\n  } else {\n    y = rect.y + rect.height / 2;\n  } // Left & Right\n\n\n  if (leftRight === 'l') {\n    x = rect.x;\n  } else if (leftRight === 'r') {\n    x = rect.x + rect.width;\n  } else {\n    x = rect.x + rect.width / 2;\n  }\n\n  return {\n    x: x,\n    y: y\n  };\n}\n\nfunction reversePoints(points, index) {\n  var reverseMap = {\n    t: 'b',\n    b: 't',\n    l: 'r',\n    r: 'l'\n  };\n  return points.map(function (point, i) {\n    if (i === index) {\n      return reverseMap[point] || 'c';\n    }\n\n    return point;\n  }).join('');\n}\n\nexport default function useAlign(open, popupEle, target, placement, builtinPlacements, popupAlign, onPopupAlign) {\n  var _React$useState = React.useState({\n    ready: false,\n    offsetX: 0,\n    offsetY: 0,\n    arrowX: 0,\n    arrowY: 0,\n    scaleX: 1,\n    scaleY: 1,\n    align: builtinPlacements[placement] || {}\n  }),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      offsetInfo = _React$useState2[0],\n      setOffsetInfo = _React$useState2[1];\n\n  var alignCountRef = React.useRef(0);\n  var scrollerList = React.useMemo(function () {\n    if (!popupEle) {\n      return [];\n    }\n\n    return collectScroller(popupEle);\n  }, [popupEle]); // ========================= Flip ==========================\n  // We will memo flip info.\n  // If size change to make flip, it will memo the flip info and use it in next align.\n\n  var prevFlipRef = React.useRef({});\n\n  var resetFlipCache = function resetFlipCache() {\n    prevFlipRef.current = {};\n  };\n\n  if (!open) {\n    resetFlipCache();\n  } // ========================= Align =========================\n\n\n  var onAlign = useEvent(function () {\n    if (popupEle && target && open) {\n      // ============== Intersection ===============\n      // Get area by position. Used for check if flip area is better\n      var getIntersectionVisibleArea = function getIntersectionVisibleArea(offsetX, offsetY) {\n        var l = popupRect.x + offsetX;\n        var t = popupRect.y + offsetY;\n        var r = l + popupWidth;\n        var b = t + popupHeight;\n        var visibleL = Math.max(l, visibleArea.left);\n        var visibleT = Math.max(t, visibleArea.top);\n        var visibleR = Math.min(r, visibleArea.right);\n        var visibleB = Math.min(b, visibleArea.bottom);\n        return Math.max(0, (visibleR - visibleL) * (visibleB - visibleT));\n      };\n\n      var syncNextPopupPosition = function syncNextPopupPosition() {\n        nextPopupY = popupRect.y + nextOffsetY;\n        nextPopupBottom = nextPopupY + popupHeight;\n        nextPopupX = popupRect.x + nextOffsetX;\n        nextPopupRight = nextPopupX + popupWidth;\n      };\n\n      var popupElement = popupEle;\n      var originLeft = popupElement.style.left;\n      var originTop = popupElement.style.top;\n      var doc = popupElement.ownerDocument;\n      var win = getWin(popupElement); // Placement\n\n      var placementInfo = _objectSpread(_objectSpread({}, builtinPlacements[placement]), popupAlign); // Reset first\n\n\n      popupElement.style.left = '0';\n      popupElement.style.top = '0'; // Calculate align style, we should consider `transform` case\n\n      var targetRect;\n\n      if (Array.isArray(target)) {\n        targetRect = {\n          x: target[0],\n          y: target[1],\n          width: 0,\n          height: 0\n        };\n      } else {\n        var rect = target.getBoundingClientRect();\n        targetRect = {\n          x: rect.x,\n          y: rect.y,\n          width: rect.width,\n          height: rect.height\n        };\n      }\n\n      var popupRect = popupElement.getBoundingClientRect();\n\n      var _win$getComputedStyle = win.getComputedStyle(popupElement),\n          width = _win$getComputedStyle.width,\n          height = _win$getComputedStyle.height;\n\n      var _doc$documentElement = doc.documentElement,\n          clientWidth = _doc$documentElement.clientWidth,\n          clientHeight = _doc$documentElement.clientHeight,\n          scrollWidth = _doc$documentElement.scrollWidth,\n          scrollHeight = _doc$documentElement.scrollHeight,\n          scrollTop = _doc$documentElement.scrollTop,\n          scrollLeft = _doc$documentElement.scrollLeft;\n      var popupHeight = popupRect.height;\n      var popupWidth = popupRect.width;\n      var targetHeight = targetRect.height;\n      var targetWidth = targetRect.width; // Get bounding of visible area\n\n      var visibleArea = placementInfo.htmlRegion === 'scroll' ? // Scroll region should take scrollLeft & scrollTop into account\n      {\n        left: -scrollLeft,\n        top: -scrollTop,\n        right: scrollWidth - scrollLeft,\n        bottom: scrollHeight - scrollTop\n      } : {\n        left: 0,\n        top: 0,\n        right: clientWidth,\n        bottom: clientHeight\n      };\n      visibleArea = getVisibleArea(visibleArea, scrollerList); // Reset back\n\n      popupElement.style.left = originLeft;\n      popupElement.style.top = originTop; // Calculate scale\n\n      var _scaleX = toNum(Math.round(popupWidth / parseFloat(width) * 1000) / 1000);\n\n      var _scaleY = toNum(Math.round(popupHeight / parseFloat(height) * 1000) / 1000); // No need to align since it's not visible in view\n\n\n      if (_scaleX === 0 || _scaleY === 0 || isDOM(target) && !isVisible(target)) {\n        return;\n      } // Offset\n\n\n      var offset = placementInfo.offset,\n          targetOffset = placementInfo.targetOffset;\n\n      var _ref = offset || [],\n          _ref2 = _slicedToArray(_ref, 2),\n          _ref2$ = _ref2[0],\n          popupOffsetX = _ref2$ === void 0 ? 0 : _ref2$,\n          _ref2$2 = _ref2[1],\n          popupOffsetY = _ref2$2 === void 0 ? 0 : _ref2$2;\n\n      var _ref3 = targetOffset || [],\n          _ref4 = _slicedToArray(_ref3, 2),\n          _ref4$ = _ref4[0],\n          targetOffsetX = _ref4$ === void 0 ? 0 : _ref4$,\n          _ref4$2 = _ref4[1],\n          targetOffsetY = _ref4$2 === void 0 ? 0 : _ref4$2;\n\n      targetRect.x += targetOffsetX;\n      targetRect.y += targetOffsetY; // Points\n\n      var _ref5 = placementInfo.points || [],\n          _ref6 = _slicedToArray(_ref5, 2),\n          popupPoint = _ref6[0],\n          targetPoint = _ref6[1];\n\n      var targetPoints = splitPoints(targetPoint);\n      var popupPoints = splitPoints(popupPoint);\n      var targetAlignPoint = getAlignPoint(targetRect, targetPoints);\n      var popupAlignPoint = getAlignPoint(popupRect, popupPoints); // Real align info may not same as origin one\n\n      var nextAlignInfo = _objectSpread({}, placementInfo); // Next Offset\n\n\n      var nextOffsetX = targetAlignPoint.x - popupAlignPoint.x + popupOffsetX;\n      var nextOffsetY = targetAlignPoint.y - popupAlignPoint.y + popupOffsetY;\n      var originIntersectionVisibleArea = getIntersectionVisibleArea(nextOffsetX, nextOffsetY); // ========================== Overflow ===========================\n\n      var targetAlignPointTL = getAlignPoint(targetRect, ['t', 'l']);\n      var popupAlignPointTL = getAlignPoint(popupRect, ['t', 'l']);\n      var targetAlignPointBR = getAlignPoint(targetRect, ['b', 'r']);\n      var popupAlignPointBR = getAlignPoint(popupRect, ['b', 'r']);\n      var overflow = placementInfo.overflow || {};\n      var adjustX = overflow.adjustX,\n          adjustY = overflow.adjustY,\n          shiftX = overflow.shiftX,\n          shiftY = overflow.shiftY;\n\n      var supportAdjust = function supportAdjust(val) {\n        if (typeof val === 'boolean') {\n          return val;\n        }\n\n        return val >= 0;\n      }; // Prepare position\n\n\n      var nextPopupY;\n      var nextPopupBottom;\n      var nextPopupX;\n      var nextPopupRight;\n      syncNextPopupPosition(); // >>>>>>>>>> Top & Bottom\n\n      var needAdjustY = supportAdjust(adjustY);\n      var sameTB = popupPoints[0] === targetPoints[0]; // Bottom to Top\n\n      if (needAdjustY && popupPoints[0] === 't' && (nextPopupBottom > visibleArea.bottom || prevFlipRef.current.bt)) {\n        var tmpNextOffsetY = nextOffsetY;\n\n        if (sameTB) {\n          tmpNextOffsetY -= popupHeight - targetHeight;\n        } else {\n          tmpNextOffsetY = targetAlignPointTL.y - popupAlignPointBR.y - popupOffsetY;\n        }\n\n        if (getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY) >= originIntersectionVisibleArea) {\n          prevFlipRef.current.bt = true;\n          nextOffsetY = tmpNextOffsetY;\n          nextAlignInfo.points = [reversePoints(popupPoints, 0), reversePoints(targetPoints, 0)];\n        } else {\n          prevFlipRef.current.bt = false;\n        }\n      } // Top to Bottom\n\n\n      if (needAdjustY && popupPoints[0] === 'b' && (nextPopupY < visibleArea.top || prevFlipRef.current.tb)) {\n        var _tmpNextOffsetY = nextOffsetY;\n\n        if (sameTB) {\n          _tmpNextOffsetY += popupHeight - targetHeight;\n        } else {\n          _tmpNextOffsetY = targetAlignPointBR.y - popupAlignPointTL.y - popupOffsetY;\n        }\n\n        if (getIntersectionVisibleArea(nextOffsetX, _tmpNextOffsetY) >= originIntersectionVisibleArea) {\n          prevFlipRef.current.tb = true;\n          nextOffsetY = _tmpNextOffsetY;\n          nextAlignInfo.points = [reversePoints(popupPoints, 0), reversePoints(targetPoints, 0)];\n        } else {\n          prevFlipRef.current.tb = false;\n        }\n      } // >>>>>>>>>> Left & Right\n\n\n      var needAdjustX = supportAdjust(adjustX); // >>>>> Flip\n\n      var sameLR = popupPoints[1] === targetPoints[1]; // Right to Left\n\n      if (needAdjustX && popupPoints[1] === 'l' && (nextPopupRight > visibleArea.right || prevFlipRef.current.rl)) {\n        var tmpNextOffsetX = nextOffsetX;\n\n        if (sameLR) {\n          tmpNextOffsetX -= popupWidth - targetWidth;\n        } else {\n          tmpNextOffsetX = targetAlignPointTL.x - popupAlignPointBR.x - popupOffsetX;\n        }\n\n        if (getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY) >= originIntersectionVisibleArea) {\n          prevFlipRef.current.rl = true;\n          nextOffsetX = tmpNextOffsetX;\n          nextAlignInfo.points = [reversePoints(popupPoints, 1), reversePoints(targetPoints, 1)];\n        } else {\n          prevFlipRef.current.rl = false;\n        }\n      } // Left to Right\n\n\n      if (needAdjustX && popupPoints[1] === 'r' && (nextPopupX < visibleArea.left || prevFlipRef.current.lr)) {\n        var _tmpNextOffsetX = nextOffsetX;\n\n        if (sameLR) {\n          _tmpNextOffsetX += popupWidth - targetWidth;\n        } else {\n          _tmpNextOffsetX = targetAlignPointBR.x - popupAlignPointTL.x - popupOffsetX;\n        }\n\n        if (getIntersectionVisibleArea(_tmpNextOffsetX, nextOffsetY) >= originIntersectionVisibleArea) {\n          prevFlipRef.current.lr = true;\n          nextOffsetX = _tmpNextOffsetX;\n          nextAlignInfo.points = [reversePoints(popupPoints, 1), reversePoints(targetPoints, 1)];\n        } else {\n          prevFlipRef.current.lr = false;\n        }\n      } // ============================ Shift ============================\n\n\n      syncNextPopupPosition();\n      var numShiftX = shiftX === true ? 0 : shiftX;\n\n      if (typeof numShiftX === 'number') {\n        // Left\n        if (nextPopupX < visibleArea.left) {\n          nextOffsetX -= nextPopupX - visibleArea.left;\n\n          if (targetRect.x + targetWidth < visibleArea.left + numShiftX) {\n            nextOffsetX += targetRect.x - visibleArea.left + targetWidth - numShiftX;\n          }\n        } // Right\n\n\n        if (nextPopupRight > visibleArea.right) {\n          nextOffsetX -= nextPopupRight - visibleArea.right;\n\n          if (targetRect.x > visibleArea.right - numShiftX) {\n            nextOffsetX += targetRect.x - visibleArea.right + numShiftX;\n          }\n        }\n      }\n\n      var numShiftY = shiftY === true ? 0 : shiftY;\n\n      if (typeof numShiftY === 'number') {\n        // Top\n        if (nextPopupY < visibleArea.top) {\n          nextOffsetY -= nextPopupY - visibleArea.top;\n\n          if (targetRect.y + targetHeight < visibleArea.top + numShiftY) {\n            nextOffsetY += targetRect.y - visibleArea.top + targetHeight - numShiftY;\n          }\n        } // Bottom\n\n\n        if (nextPopupBottom > visibleArea.bottom) {\n          nextOffsetY -= nextPopupBottom - visibleArea.bottom;\n\n          if (targetRect.y > visibleArea.bottom - numShiftY) {\n            nextOffsetY += targetRect.y - visibleArea.bottom + numShiftY;\n          }\n        }\n      } // ============================ Arrow ============================\n      // Arrow center align\n\n\n      var popupLeft = popupRect.x + nextOffsetX;\n      var popupRight = popupLeft + popupWidth;\n      var popupTop = popupRect.y + nextOffsetY;\n      var popupBottom = popupTop + popupHeight;\n      var targetLeft = targetRect.x;\n      var targetRight = targetLeft + targetWidth;\n      var targetTop = targetRect.y;\n      var targetBottom = targetTop + targetHeight;\n      var maxLeft = Math.max(popupLeft, targetLeft);\n      var minRight = Math.min(popupRight, targetRight);\n      var xCenter = (maxLeft + minRight) / 2;\n      var nextArrowX = xCenter - popupLeft;\n      var maxTop = Math.max(popupTop, targetTop);\n      var minBottom = Math.min(popupBottom, targetBottom);\n      var yCenter = (maxTop + minBottom) / 2;\n      var nextArrowY = yCenter - popupTop;\n      onPopupAlign === null || onPopupAlign === void 0 ? void 0 : onPopupAlign(popupEle, nextAlignInfo);\n      setOffsetInfo({\n        ready: true,\n        offsetX: nextOffsetX / _scaleX,\n        offsetY: nextOffsetY / _scaleY,\n        arrowX: nextArrowX / _scaleX,\n        arrowY: nextArrowY / _scaleY,\n        scaleX: _scaleX,\n        scaleY: _scaleY,\n        align: nextAlignInfo\n      });\n    }\n  });\n\n  var triggerAlign = function triggerAlign() {\n    alignCountRef.current += 1;\n    var id = alignCountRef.current; // Merge all align requirement into one frame\n\n    Promise.resolve().then(function () {\n      if (alignCountRef.current === id) {\n        onAlign();\n      }\n    });\n  }; // Reset ready status when placement & open changed\n\n\n  var resetReady = function resetReady() {\n    setOffsetInfo(function (ori) {\n      return _objectSpread(_objectSpread({}, ori), {}, {\n        ready: false\n      });\n    });\n  };\n\n  useLayoutEffect(resetReady, [placement]);\n  useLayoutEffect(function () {\n    if (!open) {\n      resetReady();\n    }\n  }, [open]);\n  return [offsetInfo.ready, offsetInfo.offsetX, offsetInfo.offsetY, offsetInfo.arrowX, offsetInfo.arrowY, offsetInfo.scaleX, offsetInfo.scaleY, offsetInfo.align, triggerAlign];\n}","map":{"version":3,"sources":["/Users/luna/Desktop/Project/Git Project/rick-Morty/node_modules/@rc-component/trigger/es/hooks/useAlign.js"],"names":["_objectSpread","_slicedToArray","isDOM","isVisible","useEvent","useLayoutEffect","React","collectScroller","getVisibleArea","getWin","toNum","splitPoints","points","arguments","length","undefined","getAlignPoint","rect","topBottom","leftRight","x","y","height","width","reversePoints","index","reverseMap","t","b","l","r","map","point","i","join","useAlign","open","popupEle","target","placement","builtinPlacements","popupAlign","onPopupAlign","_React$useState","useState","ready","offsetX","offsetY","arrowX","arrowY","scaleX","scaleY","align","_React$useState2","offsetInfo","setOffsetInfo","alignCountRef","useRef","scrollerList","useMemo","prevFlipRef","resetFlipCache","current","onAlign","getIntersectionVisibleArea","popupRect","popupWidth","popupHeight","visibleL","Math","max","visibleArea","left","visibleT","top","visibleR","min","right","visibleB","bottom","syncNextPopupPosition","nextPopupY","nextOffsetY","nextPopupBottom","nextPopupX","nextOffsetX","nextPopupRight","popupElement","originLeft","style","originTop","doc","ownerDocument","win","placementInfo","targetRect","Array","isArray","getBoundingClientRect","_win$getComputedStyle","getComputedStyle","_doc$documentElement","documentElement","clientWidth","clientHeight","scrollWidth","scrollHeight","scrollTop","scrollLeft","targetHeight","targetWidth","htmlRegion","_scaleX","round","parseFloat","_scaleY","offset","targetOffset","_ref","_ref2","_ref2$","popupOffsetX","_ref2$2","popupOffsetY","_ref3","_ref4","_ref4$","targetOffsetX","_ref4$2","targetOffsetY","_ref5","_ref6","popupPoint","targetPoint","targetPoints","popupPoints","targetAlignPoint","popupAlignPoint","nextAlignInfo","originIntersectionVisibleArea","targetAlignPointTL","popupAlignPointTL","targetAlignPointBR","popupAlignPointBR","overflow","adjustX","adjustY","shiftX","shiftY","supportAdjust","val","needAdjustY","sameTB","bt","tmpNextOffsetY","tb","_tmpNextOffsetY","needAdjustX","sameLR","rl","tmpNextOffsetX","lr","_tmpNextOffsetX","numShiftX","numShiftY","popupLeft","popupRight","popupTop","popupBottom","targetLeft","targetRight","targetTop","targetBottom","maxLeft","minRight","xCenter","nextArrowX","maxTop","minBottom","yCenter","nextArrowY","triggerAlign","id","Promise","resolve","then","resetReady","ori"],"mappings":"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","sourcesContent":["import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport { isDOM } from \"rc-util/es/Dom/findDOMNode\";\nimport isVisible from \"rc-util/es/Dom/isVisible\";\nimport useEvent from \"rc-util/es/hooks/useEvent\";\nimport useLayoutEffect from \"rc-util/es/hooks/useLayoutEffect\";\nimport * as React from 'react';\nimport { collectScroller, getVisibleArea, getWin, toNum } from \"../util\";\nfunction splitPoints() {\n  var points = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  return [points[0], points[1]];\n}\nfunction getAlignPoint(rect, points) {\n  var topBottom = points[0];\n  var leftRight = points[1];\n  var x;\n  var y;\n\n  // Top & Bottom\n  if (topBottom === 't') {\n    y = rect.y;\n  } else if (topBottom === 'b') {\n    y = rect.y + rect.height;\n  } else {\n    y = rect.y + rect.height / 2;\n  }\n\n  // Left & Right\n  if (leftRight === 'l') {\n    x = rect.x;\n  } else if (leftRight === 'r') {\n    x = rect.x + rect.width;\n  } else {\n    x = rect.x + rect.width / 2;\n  }\n  return {\n    x: x,\n    y: y\n  };\n}\nfunction reversePoints(points, index) {\n  var reverseMap = {\n    t: 'b',\n    b: 't',\n    l: 'r',\n    r: 'l'\n  };\n  return points.map(function (point, i) {\n    if (i === index) {\n      return reverseMap[point] || 'c';\n    }\n    return point;\n  }).join('');\n}\nexport default function useAlign(open, popupEle, target, placement, builtinPlacements, popupAlign, onPopupAlign) {\n  var _React$useState = React.useState({\n      ready: false,\n      offsetX: 0,\n      offsetY: 0,\n      arrowX: 0,\n      arrowY: 0,\n      scaleX: 1,\n      scaleY: 1,\n      align: builtinPlacements[placement] || {}\n    }),\n    _React$useState2 = _slicedToArray(_React$useState, 2),\n    offsetInfo = _React$useState2[0],\n    setOffsetInfo = _React$useState2[1];\n  var alignCountRef = React.useRef(0);\n  var scrollerList = React.useMemo(function () {\n    if (!popupEle) {\n      return [];\n    }\n    return collectScroller(popupEle);\n  }, [popupEle]);\n\n  // ========================= Flip ==========================\n  // We will memo flip info.\n  // If size change to make flip, it will memo the flip info and use it in next align.\n  var prevFlipRef = React.useRef({});\n  var resetFlipCache = function resetFlipCache() {\n    prevFlipRef.current = {};\n  };\n  if (!open) {\n    resetFlipCache();\n  }\n\n  // ========================= Align =========================\n  var onAlign = useEvent(function () {\n    if (popupEle && target && open) {\n      var popupElement = popupEle;\n      var originLeft = popupElement.style.left;\n      var originTop = popupElement.style.top;\n      var doc = popupElement.ownerDocument;\n      var win = getWin(popupElement);\n\n      // Placement\n      var placementInfo = _objectSpread(_objectSpread({}, builtinPlacements[placement]), popupAlign);\n\n      // Reset first\n      popupElement.style.left = '0';\n      popupElement.style.top = '0';\n\n      // Calculate align style, we should consider `transform` case\n      var targetRect;\n      if (Array.isArray(target)) {\n        targetRect = {\n          x: target[0],\n          y: target[1],\n          width: 0,\n          height: 0\n        };\n      } else {\n        var rect = target.getBoundingClientRect();\n        targetRect = {\n          x: rect.x,\n          y: rect.y,\n          width: rect.width,\n          height: rect.height\n        };\n      }\n      var popupRect = popupElement.getBoundingClientRect();\n      var _win$getComputedStyle = win.getComputedStyle(popupElement),\n        width = _win$getComputedStyle.width,\n        height = _win$getComputedStyle.height;\n      var _doc$documentElement = doc.documentElement,\n        clientWidth = _doc$documentElement.clientWidth,\n        clientHeight = _doc$documentElement.clientHeight,\n        scrollWidth = _doc$documentElement.scrollWidth,\n        scrollHeight = _doc$documentElement.scrollHeight,\n        scrollTop = _doc$documentElement.scrollTop,\n        scrollLeft = _doc$documentElement.scrollLeft;\n      var popupHeight = popupRect.height;\n      var popupWidth = popupRect.width;\n      var targetHeight = targetRect.height;\n      var targetWidth = targetRect.width;\n\n      // Get bounding of visible area\n      var visibleArea = placementInfo.htmlRegion === 'scroll' ?\n      // Scroll region should take scrollLeft & scrollTop into account\n      {\n        left: -scrollLeft,\n        top: -scrollTop,\n        right: scrollWidth - scrollLeft,\n        bottom: scrollHeight - scrollTop\n      } : {\n        left: 0,\n        top: 0,\n        right: clientWidth,\n        bottom: clientHeight\n      };\n      visibleArea = getVisibleArea(visibleArea, scrollerList);\n\n      // Reset back\n      popupElement.style.left = originLeft;\n      popupElement.style.top = originTop;\n\n      // Calculate scale\n      var _scaleX = toNum(Math.round(popupWidth / parseFloat(width) * 1000) / 1000);\n      var _scaleY = toNum(Math.round(popupHeight / parseFloat(height) * 1000) / 1000);\n\n      // No need to align since it's not visible in view\n      if (_scaleX === 0 || _scaleY === 0 || isDOM(target) && !isVisible(target)) {\n        return;\n      }\n\n      // Offset\n      var offset = placementInfo.offset,\n        targetOffset = placementInfo.targetOffset;\n      var _ref = offset || [],\n        _ref2 = _slicedToArray(_ref, 2),\n        _ref2$ = _ref2[0],\n        popupOffsetX = _ref2$ === void 0 ? 0 : _ref2$,\n        _ref2$2 = _ref2[1],\n        popupOffsetY = _ref2$2 === void 0 ? 0 : _ref2$2;\n      var _ref3 = targetOffset || [],\n        _ref4 = _slicedToArray(_ref3, 2),\n        _ref4$ = _ref4[0],\n        targetOffsetX = _ref4$ === void 0 ? 0 : _ref4$,\n        _ref4$2 = _ref4[1],\n        targetOffsetY = _ref4$2 === void 0 ? 0 : _ref4$2;\n      targetRect.x += targetOffsetX;\n      targetRect.y += targetOffsetY;\n\n      // Points\n      var _ref5 = placementInfo.points || [],\n        _ref6 = _slicedToArray(_ref5, 2),\n        popupPoint = _ref6[0],\n        targetPoint = _ref6[1];\n      var targetPoints = splitPoints(targetPoint);\n      var popupPoints = splitPoints(popupPoint);\n      var targetAlignPoint = getAlignPoint(targetRect, targetPoints);\n      var popupAlignPoint = getAlignPoint(popupRect, popupPoints);\n\n      // Real align info may not same as origin one\n      var nextAlignInfo = _objectSpread({}, placementInfo);\n\n      // Next Offset\n      var nextOffsetX = targetAlignPoint.x - popupAlignPoint.x + popupOffsetX;\n      var nextOffsetY = targetAlignPoint.y - popupAlignPoint.y + popupOffsetY;\n\n      // ============== Intersection ===============\n      // Get area by position. Used for check if flip area is better\n      function getIntersectionVisibleArea(offsetX, offsetY) {\n        var l = popupRect.x + offsetX;\n        var t = popupRect.y + offsetY;\n        var r = l + popupWidth;\n        var b = t + popupHeight;\n        var visibleL = Math.max(l, visibleArea.left);\n        var visibleT = Math.max(t, visibleArea.top);\n        var visibleR = Math.min(r, visibleArea.right);\n        var visibleB = Math.min(b, visibleArea.bottom);\n        return Math.max(0, (visibleR - visibleL) * (visibleB - visibleT));\n      }\n      var originIntersectionVisibleArea = getIntersectionVisibleArea(nextOffsetX, nextOffsetY);\n\n      // ========================== Overflow ===========================\n      var targetAlignPointTL = getAlignPoint(targetRect, ['t', 'l']);\n      var popupAlignPointTL = getAlignPoint(popupRect, ['t', 'l']);\n      var targetAlignPointBR = getAlignPoint(targetRect, ['b', 'r']);\n      var popupAlignPointBR = getAlignPoint(popupRect, ['b', 'r']);\n      var overflow = placementInfo.overflow || {};\n      var adjustX = overflow.adjustX,\n        adjustY = overflow.adjustY,\n        shiftX = overflow.shiftX,\n        shiftY = overflow.shiftY;\n      var supportAdjust = function supportAdjust(val) {\n        if (typeof val === 'boolean') {\n          return val;\n        }\n        return val >= 0;\n      };\n\n      // Prepare position\n      var nextPopupY;\n      var nextPopupBottom;\n      var nextPopupX;\n      var nextPopupRight;\n      function syncNextPopupPosition() {\n        nextPopupY = popupRect.y + nextOffsetY;\n        nextPopupBottom = nextPopupY + popupHeight;\n        nextPopupX = popupRect.x + nextOffsetX;\n        nextPopupRight = nextPopupX + popupWidth;\n      }\n      syncNextPopupPosition();\n\n      // >>>>>>>>>> Top & Bottom\n      var needAdjustY = supportAdjust(adjustY);\n      var sameTB = popupPoints[0] === targetPoints[0];\n\n      // Bottom to Top\n      if (needAdjustY && popupPoints[0] === 't' && (nextPopupBottom > visibleArea.bottom || prevFlipRef.current.bt)) {\n        var tmpNextOffsetY = nextOffsetY;\n        if (sameTB) {\n          tmpNextOffsetY -= popupHeight - targetHeight;\n        } else {\n          tmpNextOffsetY = targetAlignPointTL.y - popupAlignPointBR.y - popupOffsetY;\n        }\n        if (getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY) >= originIntersectionVisibleArea) {\n          prevFlipRef.current.bt = true;\n          nextOffsetY = tmpNextOffsetY;\n          nextAlignInfo.points = [reversePoints(popupPoints, 0), reversePoints(targetPoints, 0)];\n        } else {\n          prevFlipRef.current.bt = false;\n        }\n      }\n\n      // Top to Bottom\n      if (needAdjustY && popupPoints[0] === 'b' && (nextPopupY < visibleArea.top || prevFlipRef.current.tb)) {\n        var _tmpNextOffsetY = nextOffsetY;\n        if (sameTB) {\n          _tmpNextOffsetY += popupHeight - targetHeight;\n        } else {\n          _tmpNextOffsetY = targetAlignPointBR.y - popupAlignPointTL.y - popupOffsetY;\n        }\n        if (getIntersectionVisibleArea(nextOffsetX, _tmpNextOffsetY) >= originIntersectionVisibleArea) {\n          prevFlipRef.current.tb = true;\n          nextOffsetY = _tmpNextOffsetY;\n          nextAlignInfo.points = [reversePoints(popupPoints, 0), reversePoints(targetPoints, 0)];\n        } else {\n          prevFlipRef.current.tb = false;\n        }\n      }\n\n      // >>>>>>>>>> Left & Right\n      var needAdjustX = supportAdjust(adjustX);\n\n      // >>>>> Flip\n      var sameLR = popupPoints[1] === targetPoints[1];\n\n      // Right to Left\n      if (needAdjustX && popupPoints[1] === 'l' && (nextPopupRight > visibleArea.right || prevFlipRef.current.rl)) {\n        var tmpNextOffsetX = nextOffsetX;\n        if (sameLR) {\n          tmpNextOffsetX -= popupWidth - targetWidth;\n        } else {\n          tmpNextOffsetX = targetAlignPointTL.x - popupAlignPointBR.x - popupOffsetX;\n        }\n        if (getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY) >= originIntersectionVisibleArea) {\n          prevFlipRef.current.rl = true;\n          nextOffsetX = tmpNextOffsetX;\n          nextAlignInfo.points = [reversePoints(popupPoints, 1), reversePoints(targetPoints, 1)];\n        } else {\n          prevFlipRef.current.rl = false;\n        }\n      }\n\n      // Left to Right\n      if (needAdjustX && popupPoints[1] === 'r' && (nextPopupX < visibleArea.left || prevFlipRef.current.lr)) {\n        var _tmpNextOffsetX = nextOffsetX;\n        if (sameLR) {\n          _tmpNextOffsetX += popupWidth - targetWidth;\n        } else {\n          _tmpNextOffsetX = targetAlignPointBR.x - popupAlignPointTL.x - popupOffsetX;\n        }\n        if (getIntersectionVisibleArea(_tmpNextOffsetX, nextOffsetY) >= originIntersectionVisibleArea) {\n          prevFlipRef.current.lr = true;\n          nextOffsetX = _tmpNextOffsetX;\n          nextAlignInfo.points = [reversePoints(popupPoints, 1), reversePoints(targetPoints, 1)];\n        } else {\n          prevFlipRef.current.lr = false;\n        }\n      }\n\n      // ============================ Shift ============================\n      syncNextPopupPosition();\n      var numShiftX = shiftX === true ? 0 : shiftX;\n      if (typeof numShiftX === 'number') {\n        // Left\n        if (nextPopupX < visibleArea.left) {\n          nextOffsetX -= nextPopupX - visibleArea.left;\n          if (targetRect.x + targetWidth < visibleArea.left + numShiftX) {\n            nextOffsetX += targetRect.x - visibleArea.left + targetWidth - numShiftX;\n          }\n        }\n\n        // Right\n        if (nextPopupRight > visibleArea.right) {\n          nextOffsetX -= nextPopupRight - visibleArea.right;\n          if (targetRect.x > visibleArea.right - numShiftX) {\n            nextOffsetX += targetRect.x - visibleArea.right + numShiftX;\n          }\n        }\n      }\n      var numShiftY = shiftY === true ? 0 : shiftY;\n      if (typeof numShiftY === 'number') {\n        // Top\n        if (nextPopupY < visibleArea.top) {\n          nextOffsetY -= nextPopupY - visibleArea.top;\n          if (targetRect.y + targetHeight < visibleArea.top + numShiftY) {\n            nextOffsetY += targetRect.y - visibleArea.top + targetHeight - numShiftY;\n          }\n        }\n\n        // Bottom\n        if (nextPopupBottom > visibleArea.bottom) {\n          nextOffsetY -= nextPopupBottom - visibleArea.bottom;\n          if (targetRect.y > visibleArea.bottom - numShiftY) {\n            nextOffsetY += targetRect.y - visibleArea.bottom + numShiftY;\n          }\n        }\n      }\n\n      // ============================ Arrow ============================\n      // Arrow center align\n      var popupLeft = popupRect.x + nextOffsetX;\n      var popupRight = popupLeft + popupWidth;\n      var popupTop = popupRect.y + nextOffsetY;\n      var popupBottom = popupTop + popupHeight;\n      var targetLeft = targetRect.x;\n      var targetRight = targetLeft + targetWidth;\n      var targetTop = targetRect.y;\n      var targetBottom = targetTop + targetHeight;\n      var maxLeft = Math.max(popupLeft, targetLeft);\n      var minRight = Math.min(popupRight, targetRight);\n      var xCenter = (maxLeft + minRight) / 2;\n      var nextArrowX = xCenter - popupLeft;\n      var maxTop = Math.max(popupTop, targetTop);\n      var minBottom = Math.min(popupBottom, targetBottom);\n      var yCenter = (maxTop + minBottom) / 2;\n      var nextArrowY = yCenter - popupTop;\n      onPopupAlign === null || onPopupAlign === void 0 ? void 0 : onPopupAlign(popupEle, nextAlignInfo);\n      setOffsetInfo({\n        ready: true,\n        offsetX: nextOffsetX / _scaleX,\n        offsetY: nextOffsetY / _scaleY,\n        arrowX: nextArrowX / _scaleX,\n        arrowY: nextArrowY / _scaleY,\n        scaleX: _scaleX,\n        scaleY: _scaleY,\n        align: nextAlignInfo\n      });\n    }\n  });\n  var triggerAlign = function triggerAlign() {\n    alignCountRef.current += 1;\n    var id = alignCountRef.current;\n\n    // Merge all align requirement into one frame\n    Promise.resolve().then(function () {\n      if (alignCountRef.current === id) {\n        onAlign();\n      }\n    });\n  };\n\n  // Reset ready status when placement & open changed\n  var resetReady = function resetReady() {\n    setOffsetInfo(function (ori) {\n      return _objectSpread(_objectSpread({}, ori), {}, {\n        ready: false\n      });\n    });\n  };\n  useLayoutEffect(resetReady, [placement]);\n  useLayoutEffect(function () {\n    if (!open) {\n      resetReady();\n    }\n  }, [open]);\n  return [offsetInfo.ready, offsetInfo.offsetX, offsetInfo.offsetY, offsetInfo.arrowX, offsetInfo.arrowY, offsetInfo.scaleX, offsetInfo.scaleY, offsetInfo.align, triggerAlign];\n}"]},"metadata":{},"sourceType":"module"}