{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport MutateObserver from '@rc-component/mutate-observer';\nimport classNames from 'classnames';\nimport React, { useEffect, useRef } from 'react';\nimport { getPixelRatio, getStyleStr, reRendering, rotateWatermark } from './utils';\n/**\n * Base size of the canvas, 1 for parallel layout and 2 for alternate layout\n * Only alternate layout is currently supported\n */\n\nconst BaseSize = 2;\nconst FontGap = 3;\n\nconst Watermark = props => {\n  var _a, _b;\n\n  const {\n    /**\n     * The antd content layer zIndex is basically below 10\n     * https://github.com/ant-design/ant-design/blob/6192403b2ce517c017f9e58a32d58774921c10cd/components/style/themes/default.less#L335\n     */\n    zIndex = 9,\n    rotate = -22,\n    width,\n    height,\n    image,\n    content,\n    font = {},\n    style,\n    className,\n    rootClassName,\n    gap = [100, 100],\n    offset,\n    children\n  } = props;\n  const {\n    color = 'rgba(0,0,0,.15)',\n    fontSize = 16,\n    fontWeight = 'normal',\n    fontStyle = 'normal',\n    fontFamily = 'sans-serif'\n  } = font;\n  const [gapX, gapY] = gap;\n  const gapXCenter = gapX / 2;\n  const gapYCenter = gapY / 2;\n  const offsetLeft = (_a = offset === null || offset === void 0 ? void 0 : offset[0]) !== null && _a !== void 0 ? _a : gapXCenter;\n  const offsetTop = (_b = offset === null || offset === void 0 ? void 0 : offset[1]) !== null && _b !== void 0 ? _b : gapYCenter;\n\n  const getMarkStyle = () => {\n    const markStyle = {\n      zIndex,\n      position: 'absolute',\n      left: 0,\n      top: 0,\n      width: '100%',\n      height: '100%',\n      pointerEvents: 'none',\n      backgroundRepeat: 'repeat'\n    };\n    /** Calculate the style of the offset */\n\n    let positionLeft = offsetLeft - gapXCenter;\n    let positionTop = offsetTop - gapYCenter;\n\n    if (positionLeft > 0) {\n      markStyle.left = `${positionLeft}px`;\n      markStyle.width = `calc(100% - ${positionLeft}px)`;\n      positionLeft = 0;\n    }\n\n    if (positionTop > 0) {\n      markStyle.top = `${positionTop}px`;\n      markStyle.height = `calc(100% - ${positionTop}px)`;\n      positionTop = 0;\n    }\n\n    markStyle.backgroundPosition = `${positionLeft}px ${positionTop}px`;\n    return markStyle;\n  };\n\n  const containerRef = useRef(null);\n  const watermarkRef = useRef();\n  const stopObservation = useRef(false);\n\n  const destroyWatermark = () => {\n    if (watermarkRef.current) {\n      watermarkRef.current.remove();\n      watermarkRef.current = undefined;\n    }\n  };\n\n  const appendWatermark = (base64Url, markWidth) => {\n    var _a;\n\n    if (containerRef.current && watermarkRef.current) {\n      stopObservation.current = true;\n      watermarkRef.current.setAttribute('style', getStyleStr(Object.assign(Object.assign({}, getMarkStyle()), {\n        backgroundImage: `url('${base64Url}')`,\n        backgroundSize: `${(gapX + markWidth) * BaseSize}px`\n      })));\n      (_a = containerRef.current) === null || _a === void 0 ? void 0 : _a.append(watermarkRef.current); // Delayed execution\n\n      setTimeout(() => {\n        stopObservation.current = false;\n      });\n    }\n  };\n  /**\n   * Get the width and height of the watermark. The default values are as follows\n   * Image: [120, 64]; Content: It's calculated by content;\n   */\n\n\n  const getMarkSize = ctx => {\n    let defaultWidth = 120;\n    let defaultHeight = 64;\n\n    if (!image && ctx.measureText) {\n      ctx.font = `${Number(fontSize)}px ${fontFamily}`;\n      const contents = Array.isArray(content) ? content : [content];\n      const widths = contents.map(item => ctx.measureText(item).width);\n      defaultWidth = Math.ceil(Math.max.apply(Math, _toConsumableArray(widths)));\n      defaultHeight = Number(fontSize) * contents.length + (contents.length - 1) * FontGap;\n    }\n\n    return [width !== null && width !== void 0 ? width : defaultWidth, height !== null && height !== void 0 ? height : defaultHeight];\n  };\n\n  const fillTexts = (ctx, drawX, drawY, drawWidth, drawHeight) => {\n    const ratio = getPixelRatio();\n    const mergedFontSize = Number(fontSize) * ratio;\n    ctx.font = `${fontStyle} normal ${fontWeight} ${mergedFontSize}px/${drawHeight}px ${fontFamily}`;\n    ctx.fillStyle = color;\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'top';\n    ctx.translate(drawWidth / 2, 0);\n    const contents = Array.isArray(content) ? content : [content];\n    contents === null || contents === void 0 ? void 0 : contents.forEach((item, index) => {\n      ctx.fillText(item !== null && item !== void 0 ? item : '', drawX, drawY + index * (mergedFontSize + FontGap * ratio));\n    });\n  };\n\n  const drawText = (canvas, ctx, drawX, drawY, drawWidth, drawHeight, alternateRotateX, alternateRotateY, alternateDrawX, alternateDrawY, markWidth) => {\n    fillTexts(ctx, drawX, drawY, drawWidth, drawHeight);\n    /** Fill the interleaved text after rotation */\n\n    ctx.restore();\n    rotateWatermark(ctx, alternateRotateX, alternateRotateY, rotate);\n    fillTexts(ctx, alternateDrawX, alternateDrawY, drawWidth, drawHeight);\n    appendWatermark(canvas.toDataURL(), markWidth);\n  };\n\n  const renderWatermark = () => {\n    const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n\n    if (ctx) {\n      if (!watermarkRef.current) {\n        watermarkRef.current = document.createElement('div');\n      }\n\n      const ratio = getPixelRatio();\n      const [markWidth, markHeight] = getMarkSize(ctx);\n      const canvasWidth = (gapX + markWidth) * ratio;\n      const canvasHeight = (gapY + markHeight) * ratio;\n      canvas.setAttribute('width', `${canvasWidth * BaseSize}px`);\n      canvas.setAttribute('height', `${canvasHeight * BaseSize}px`);\n      const drawX = gapX * ratio / 2;\n      const drawY = gapY * ratio / 2;\n      const drawWidth = markWidth * ratio;\n      const drawHeight = markHeight * ratio;\n      const rotateX = (drawWidth + gapX * ratio) / 2;\n      const rotateY = (drawHeight + gapY * ratio) / 2;\n      /** Alternate drawing parameters */\n\n      const alternateDrawX = drawX + canvasWidth;\n      const alternateDrawY = drawY + canvasHeight;\n      const alternateRotateX = rotateX + canvasWidth;\n      const alternateRotateY = rotateY + canvasHeight;\n      ctx.save();\n      rotateWatermark(ctx, rotateX, rotateY, rotate);\n\n      if (image) {\n        const img = new Image();\n\n        img.onload = () => {\n          ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);\n          /** Draw interleaved pictures after rotation */\n\n          ctx.restore();\n          rotateWatermark(ctx, alternateRotateX, alternateRotateY, rotate);\n          ctx.drawImage(img, alternateDrawX, alternateDrawY, drawWidth, drawHeight);\n          appendWatermark(canvas.toDataURL(), markWidth);\n        };\n\n        img.onerror = () => drawText(canvas, ctx, drawX, drawY, drawWidth, drawHeight, alternateRotateX, alternateRotateY, alternateDrawX, alternateDrawY, markWidth);\n\n        img.crossOrigin = 'anonymous';\n        img.referrerPolicy = 'no-referrer';\n        img.src = image;\n      } else {\n        drawText(canvas, ctx, drawX, drawY, drawWidth, drawHeight, alternateRotateX, alternateRotateY, alternateDrawX, alternateDrawY, markWidth);\n      }\n    }\n  };\n\n  const onMutate = mutations => {\n    if (stopObservation.current) {\n      return;\n    }\n\n    mutations.forEach(mutation => {\n      if (reRendering(mutation, watermarkRef.current)) {\n        destroyWatermark();\n        renderWatermark();\n      }\n    });\n  };\n\n  useEffect(renderWatermark, [rotate, zIndex, width, height, image, content, color, fontSize, fontWeight, fontStyle, fontFamily, gapX, gapY, offsetLeft, offsetTop]);\n  return /*#__PURE__*/React.createElement(MutateObserver, {\n    onMutate: onMutate\n  }, /*#__PURE__*/React.createElement(\"div\", {\n    ref: containerRef,\n    className: classNames(className, rootClassName),\n    style: Object.assign({\n      position: 'relative'\n    }, style)\n  }, children));\n};\n\nif (process.env.NODE_ENV !== 'production') {\n  Watermark.displayName = 'Watermark';\n}\n\nexport default Watermark;","map":{"version":3,"sources":["/Users/luna/Desktop/Project/Git Project/rick-Morty/node_modules/antd/es/watermark/index.js"],"names":["_toConsumableArray","MutateObserver","classNames","React","useEffect","useRef","getPixelRatio","getStyleStr","reRendering","rotateWatermark","BaseSize","FontGap","Watermark","props","_a","_b","zIndex","rotate","width","height","image","content","font","style","className","rootClassName","gap","offset","children","color","fontSize","fontWeight","fontStyle","fontFamily","gapX","gapY","gapXCenter","gapYCenter","offsetLeft","offsetTop","getMarkStyle","markStyle","position","left","top","pointerEvents","backgroundRepeat","positionLeft","positionTop","backgroundPosition","containerRef","watermarkRef","stopObservation","destroyWatermark","current","remove","undefined","appendWatermark","base64Url","markWidth","setAttribute","Object","assign","backgroundImage","backgroundSize","append","setTimeout","getMarkSize","ctx","defaultWidth","defaultHeight","measureText","Number","contents","Array","isArray","widths","map","item","Math","ceil","max","apply","length","fillTexts","drawX","drawY","drawWidth","drawHeight","ratio","mergedFontSize","fillStyle","textAlign","textBaseline","translate","forEach","index","fillText","drawText","canvas","alternateRotateX","alternateRotateY","alternateDrawX","alternateDrawY","restore","toDataURL","renderWatermark","document","createElement","getContext","markHeight","canvasWidth","canvasHeight","rotateX","rotateY","save","img","Image","onload","drawImage","onerror","crossOrigin","referrerPolicy","src","onMutate","mutations","mutation","ref","process","env","NODE_ENV","displayName"],"mappings":"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","sourcesContent":["import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport MutateObserver from '@rc-component/mutate-observer';\nimport classNames from 'classnames';\nimport React, { useEffect, useRef } from 'react';\nimport { getPixelRatio, getStyleStr, reRendering, rotateWatermark } from './utils';\n/**\n * Base size of the canvas, 1 for parallel layout and 2 for alternate layout\n * Only alternate layout is currently supported\n */\nconst BaseSize = 2;\nconst FontGap = 3;\nconst Watermark = props => {\n  var _a, _b;\n  const {\n    /**\n     * The antd content layer zIndex is basically below 10\n     * https://github.com/ant-design/ant-design/blob/6192403b2ce517c017f9e58a32d58774921c10cd/components/style/themes/default.less#L335\n     */\n    zIndex = 9,\n    rotate = -22,\n    width,\n    height,\n    image,\n    content,\n    font = {},\n    style,\n    className,\n    rootClassName,\n    gap = [100, 100],\n    offset,\n    children\n  } = props;\n  const {\n    color = 'rgba(0,0,0,.15)',\n    fontSize = 16,\n    fontWeight = 'normal',\n    fontStyle = 'normal',\n    fontFamily = 'sans-serif'\n  } = font;\n  const [gapX, gapY] = gap;\n  const gapXCenter = gapX / 2;\n  const gapYCenter = gapY / 2;\n  const offsetLeft = (_a = offset === null || offset === void 0 ? void 0 : offset[0]) !== null && _a !== void 0 ? _a : gapXCenter;\n  const offsetTop = (_b = offset === null || offset === void 0 ? void 0 : offset[1]) !== null && _b !== void 0 ? _b : gapYCenter;\n  const getMarkStyle = () => {\n    const markStyle = {\n      zIndex,\n      position: 'absolute',\n      left: 0,\n      top: 0,\n      width: '100%',\n      height: '100%',\n      pointerEvents: 'none',\n      backgroundRepeat: 'repeat'\n    };\n    /** Calculate the style of the offset */\n    let positionLeft = offsetLeft - gapXCenter;\n    let positionTop = offsetTop - gapYCenter;\n    if (positionLeft > 0) {\n      markStyle.left = `${positionLeft}px`;\n      markStyle.width = `calc(100% - ${positionLeft}px)`;\n      positionLeft = 0;\n    }\n    if (positionTop > 0) {\n      markStyle.top = `${positionTop}px`;\n      markStyle.height = `calc(100% - ${positionTop}px)`;\n      positionTop = 0;\n    }\n    markStyle.backgroundPosition = `${positionLeft}px ${positionTop}px`;\n    return markStyle;\n  };\n  const containerRef = useRef(null);\n  const watermarkRef = useRef();\n  const stopObservation = useRef(false);\n  const destroyWatermark = () => {\n    if (watermarkRef.current) {\n      watermarkRef.current.remove();\n      watermarkRef.current = undefined;\n    }\n  };\n  const appendWatermark = (base64Url, markWidth) => {\n    var _a;\n    if (containerRef.current && watermarkRef.current) {\n      stopObservation.current = true;\n      watermarkRef.current.setAttribute('style', getStyleStr(Object.assign(Object.assign({}, getMarkStyle()), {\n        backgroundImage: `url('${base64Url}')`,\n        backgroundSize: `${(gapX + markWidth) * BaseSize}px`\n      })));\n      (_a = containerRef.current) === null || _a === void 0 ? void 0 : _a.append(watermarkRef.current);\n      // Delayed execution\n      setTimeout(() => {\n        stopObservation.current = false;\n      });\n    }\n  };\n  /**\n   * Get the width and height of the watermark. The default values are as follows\n   * Image: [120, 64]; Content: It's calculated by content;\n   */\n  const getMarkSize = ctx => {\n    let defaultWidth = 120;\n    let defaultHeight = 64;\n    if (!image && ctx.measureText) {\n      ctx.font = `${Number(fontSize)}px ${fontFamily}`;\n      const contents = Array.isArray(content) ? content : [content];\n      const widths = contents.map(item => ctx.measureText(item).width);\n      defaultWidth = Math.ceil(Math.max.apply(Math, _toConsumableArray(widths)));\n      defaultHeight = Number(fontSize) * contents.length + (contents.length - 1) * FontGap;\n    }\n    return [width !== null && width !== void 0 ? width : defaultWidth, height !== null && height !== void 0 ? height : defaultHeight];\n  };\n  const fillTexts = (ctx, drawX, drawY, drawWidth, drawHeight) => {\n    const ratio = getPixelRatio();\n    const mergedFontSize = Number(fontSize) * ratio;\n    ctx.font = `${fontStyle} normal ${fontWeight} ${mergedFontSize}px/${drawHeight}px ${fontFamily}`;\n    ctx.fillStyle = color;\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'top';\n    ctx.translate(drawWidth / 2, 0);\n    const contents = Array.isArray(content) ? content : [content];\n    contents === null || contents === void 0 ? void 0 : contents.forEach((item, index) => {\n      ctx.fillText(item !== null && item !== void 0 ? item : '', drawX, drawY + index * (mergedFontSize + FontGap * ratio));\n    });\n  };\n  const drawText = (canvas, ctx, drawX, drawY, drawWidth, drawHeight, alternateRotateX, alternateRotateY, alternateDrawX, alternateDrawY, markWidth) => {\n    fillTexts(ctx, drawX, drawY, drawWidth, drawHeight);\n    /** Fill the interleaved text after rotation */\n    ctx.restore();\n    rotateWatermark(ctx, alternateRotateX, alternateRotateY, rotate);\n    fillTexts(ctx, alternateDrawX, alternateDrawY, drawWidth, drawHeight);\n    appendWatermark(canvas.toDataURL(), markWidth);\n  };\n  const renderWatermark = () => {\n    const canvas = document.createElement('canvas');\n    const ctx = canvas.getContext('2d');\n    if (ctx) {\n      if (!watermarkRef.current) {\n        watermarkRef.current = document.createElement('div');\n      }\n      const ratio = getPixelRatio();\n      const [markWidth, markHeight] = getMarkSize(ctx);\n      const canvasWidth = (gapX + markWidth) * ratio;\n      const canvasHeight = (gapY + markHeight) * ratio;\n      canvas.setAttribute('width', `${canvasWidth * BaseSize}px`);\n      canvas.setAttribute('height', `${canvasHeight * BaseSize}px`);\n      const drawX = gapX * ratio / 2;\n      const drawY = gapY * ratio / 2;\n      const drawWidth = markWidth * ratio;\n      const drawHeight = markHeight * ratio;\n      const rotateX = (drawWidth + gapX * ratio) / 2;\n      const rotateY = (drawHeight + gapY * ratio) / 2;\n      /** Alternate drawing parameters */\n      const alternateDrawX = drawX + canvasWidth;\n      const alternateDrawY = drawY + canvasHeight;\n      const alternateRotateX = rotateX + canvasWidth;\n      const alternateRotateY = rotateY + canvasHeight;\n      ctx.save();\n      rotateWatermark(ctx, rotateX, rotateY, rotate);\n      if (image) {\n        const img = new Image();\n        img.onload = () => {\n          ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);\n          /** Draw interleaved pictures after rotation */\n          ctx.restore();\n          rotateWatermark(ctx, alternateRotateX, alternateRotateY, rotate);\n          ctx.drawImage(img, alternateDrawX, alternateDrawY, drawWidth, drawHeight);\n          appendWatermark(canvas.toDataURL(), markWidth);\n        };\n        img.onerror = () => drawText(canvas, ctx, drawX, drawY, drawWidth, drawHeight, alternateRotateX, alternateRotateY, alternateDrawX, alternateDrawY, markWidth);\n        img.crossOrigin = 'anonymous';\n        img.referrerPolicy = 'no-referrer';\n        img.src = image;\n      } else {\n        drawText(canvas, ctx, drawX, drawY, drawWidth, drawHeight, alternateRotateX, alternateRotateY, alternateDrawX, alternateDrawY, markWidth);\n      }\n    }\n  };\n  const onMutate = mutations => {\n    if (stopObservation.current) {\n      return;\n    }\n    mutations.forEach(mutation => {\n      if (reRendering(mutation, watermarkRef.current)) {\n        destroyWatermark();\n        renderWatermark();\n      }\n    });\n  };\n  useEffect(renderWatermark, [rotate, zIndex, width, height, image, content, color, fontSize, fontWeight, fontStyle, fontFamily, gapX, gapY, offsetLeft, offsetTop]);\n  return /*#__PURE__*/React.createElement(MutateObserver, {\n    onMutate: onMutate\n  }, /*#__PURE__*/React.createElement(\"div\", {\n    ref: containerRef,\n    className: classNames(className, rootClassName),\n    style: Object.assign({\n      position: 'relative'\n    }, style)\n  }, children));\n};\nif (process.env.NODE_ENV !== 'production') {\n  Watermark.displayName = 'Watermark';\n}\nexport default Watermark;"]},"metadata":{},"sourceType":"module"}