{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport { useRef, useState, useEffect } from 'react';\n/**\n * Execute code before next frame but async\n */\n\nexport function useLayoutState(defaultState) {\n  var stateRef = useRef(defaultState);\n\n  var _useState = useState({}),\n      _useState2 = _slicedToArray(_useState, 2),\n      forceUpdate = _useState2[1];\n\n  var lastPromiseRef = useRef(null);\n  var updateBatchRef = useRef([]);\n\n  function setFrameState(updater) {\n    updateBatchRef.current.push(updater);\n    var promise = Promise.resolve();\n    lastPromiseRef.current = promise;\n    promise.then(function () {\n      if (lastPromiseRef.current === promise) {\n        var prevBatch = updateBatchRef.current;\n        var prevState = stateRef.current;\n        updateBatchRef.current = [];\n        prevBatch.forEach(function (batchUpdater) {\n          stateRef.current = batchUpdater(stateRef.current);\n        });\n        lastPromiseRef.current = null;\n\n        if (prevState !== stateRef.current) {\n          forceUpdate({});\n        }\n      }\n    });\n  }\n\n  useEffect(function () {\n    return function () {\n      lastPromiseRef.current = null;\n    };\n  }, []);\n  return [stateRef.current, setFrameState];\n}\n/** Lock frame, when frame pass reset the lock. */\n\nexport function useTimeoutLock(defaultState) {\n  var frameRef = useRef(defaultState || null);\n  var timeoutRef = useRef();\n\n  function cleanUp() {\n    window.clearTimeout(timeoutRef.current);\n  }\n\n  function setState(newState) {\n    frameRef.current = newState;\n    cleanUp();\n    timeoutRef.current = window.setTimeout(function () {\n      frameRef.current = null;\n      timeoutRef.current = undefined;\n    }, 100);\n  }\n\n  function getState() {\n    return frameRef.current;\n  }\n\n  useEffect(function () {\n    return cleanUp;\n  }, []);\n  return [setState, getState];\n}","map":{"version":3,"sources":["/Users/luna/Desktop/Project/Git Project/rick-Morty/node_modules/rc-table/es/hooks/useFrame.js"],"names":["_slicedToArray","useRef","useState","useEffect","useLayoutState","defaultState","stateRef","_useState","_useState2","forceUpdate","lastPromiseRef","updateBatchRef","setFrameState","updater","current","push","promise","Promise","resolve","then","prevBatch","prevState","forEach","batchUpdater","useTimeoutLock","frameRef","timeoutRef","cleanUp","window","clearTimeout","setState","newState","setTimeout","undefined","getState"],"mappings":"AAAA,OAAOA,cAAP,MAA2B,0CAA3B;AACA,SAASC,MAAT,EAAiBC,QAAjB,EAA2BC,SAA3B,QAA4C,OAA5C;AACA;AACA;AACA;;AACA,OAAO,SAASC,cAAT,CAAwBC,YAAxB,EAAsC;AAC3C,MAAIC,QAAQ,GAAGL,MAAM,CAACI,YAAD,CAArB;;AACA,MAAIE,SAAS,GAAGL,QAAQ,CAAC,EAAD,CAAxB;AAAA,MACEM,UAAU,GAAGR,cAAc,CAACO,SAAD,EAAY,CAAZ,CAD7B;AAAA,MAEEE,WAAW,GAAGD,UAAU,CAAC,CAAD,CAF1B;;AAGA,MAAIE,cAAc,GAAGT,MAAM,CAAC,IAAD,CAA3B;AACA,MAAIU,cAAc,GAAGV,MAAM,CAAC,EAAD,CAA3B;;AACA,WAASW,aAAT,CAAuBC,OAAvB,EAAgC;AAC9BF,IAAAA,cAAc,CAACG,OAAf,CAAuBC,IAAvB,CAA4BF,OAA5B;AACA,QAAIG,OAAO,GAAGC,OAAO,CAACC,OAAR,EAAd;AACAR,IAAAA,cAAc,CAACI,OAAf,GAAyBE,OAAzB;AACAA,IAAAA,OAAO,CAACG,IAAR,CAAa,YAAY;AACvB,UAAIT,cAAc,CAACI,OAAf,KAA2BE,OAA/B,EAAwC;AACtC,YAAII,SAAS,GAAGT,cAAc,CAACG,OAA/B;AACA,YAAIO,SAAS,GAAGf,QAAQ,CAACQ,OAAzB;AACAH,QAAAA,cAAc,CAACG,OAAf,GAAyB,EAAzB;AACAM,QAAAA,SAAS,CAACE,OAAV,CAAkB,UAAUC,YAAV,EAAwB;AACxCjB,UAAAA,QAAQ,CAACQ,OAAT,GAAmBS,YAAY,CAACjB,QAAQ,CAACQ,OAAV,CAA/B;AACD,SAFD;AAGAJ,QAAAA,cAAc,CAACI,OAAf,GAAyB,IAAzB;;AACA,YAAIO,SAAS,KAAKf,QAAQ,CAACQ,OAA3B,EAAoC;AAClCL,UAAAA,WAAW,CAAC,EAAD,CAAX;AACD;AACF;AACF,KAbD;AAcD;;AACDN,EAAAA,SAAS,CAAC,YAAY;AACpB,WAAO,YAAY;AACjBO,MAAAA,cAAc,CAACI,OAAf,GAAyB,IAAzB;AACD,KAFD;AAGD,GAJQ,EAIN,EAJM,CAAT;AAKA,SAAO,CAACR,QAAQ,CAACQ,OAAV,EAAmBF,aAAnB,CAAP;AACD;AAED;;AACA,OAAO,SAASY,cAAT,CAAwBnB,YAAxB,EAAsC;AAC3C,MAAIoB,QAAQ,GAAGxB,MAAM,CAACI,YAAY,IAAI,IAAjB,CAArB;AACA,MAAIqB,UAAU,GAAGzB,MAAM,EAAvB;;AACA,WAAS0B,OAAT,GAAmB;AACjBC,IAAAA,MAAM,CAACC,YAAP,CAAoBH,UAAU,CAACZ,OAA/B;AACD;;AACD,WAASgB,QAAT,CAAkBC,QAAlB,EAA4B;AAC1BN,IAAAA,QAAQ,CAACX,OAAT,GAAmBiB,QAAnB;AACAJ,IAAAA,OAAO;AACPD,IAAAA,UAAU,CAACZ,OAAX,GAAqBc,MAAM,CAACI,UAAP,CAAkB,YAAY;AACjDP,MAAAA,QAAQ,CAACX,OAAT,GAAmB,IAAnB;AACAY,MAAAA,UAAU,CAACZ,OAAX,GAAqBmB,SAArB;AACD,KAHoB,EAGlB,GAHkB,CAArB;AAID;;AACD,WAASC,QAAT,GAAoB;AAClB,WAAOT,QAAQ,CAACX,OAAhB;AACD;;AACDX,EAAAA,SAAS,CAAC,YAAY;AACpB,WAAOwB,OAAP;AACD,GAFQ,EAEN,EAFM,CAAT;AAGA,SAAO,CAACG,QAAD,EAAWI,QAAX,CAAP;AACD","sourcesContent":["import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport { useRef, useState, useEffect } from 'react';\n/**\n * Execute code before next frame but async\n */\nexport function useLayoutState(defaultState) {\n  var stateRef = useRef(defaultState);\n  var _useState = useState({}),\n    _useState2 = _slicedToArray(_useState, 2),\n    forceUpdate = _useState2[1];\n  var lastPromiseRef = useRef(null);\n  var updateBatchRef = useRef([]);\n  function setFrameState(updater) {\n    updateBatchRef.current.push(updater);\n    var promise = Promise.resolve();\n    lastPromiseRef.current = promise;\n    promise.then(function () {\n      if (lastPromiseRef.current === promise) {\n        var prevBatch = updateBatchRef.current;\n        var prevState = stateRef.current;\n        updateBatchRef.current = [];\n        prevBatch.forEach(function (batchUpdater) {\n          stateRef.current = batchUpdater(stateRef.current);\n        });\n        lastPromiseRef.current = null;\n        if (prevState !== stateRef.current) {\n          forceUpdate({});\n        }\n      }\n    });\n  }\n  useEffect(function () {\n    return function () {\n      lastPromiseRef.current = null;\n    };\n  }, []);\n  return [stateRef.current, setFrameState];\n}\n\n/** Lock frame, when frame pass reset the lock. */\nexport function useTimeoutLock(defaultState) {\n  var frameRef = useRef(defaultState || null);\n  var timeoutRef = useRef();\n  function cleanUp() {\n    window.clearTimeout(timeoutRef.current);\n  }\n  function setState(newState) {\n    frameRef.current = newState;\n    cleanUp();\n    timeoutRef.current = window.setTimeout(function () {\n      frameRef.current = null;\n      timeoutRef.current = undefined;\n    }, 100);\n  }\n  function getState() {\n    return frameRef.current;\n  }\n  useEffect(function () {\n    return cleanUp;\n  }, []);\n  return [setState, getState];\n}"]},"metadata":{},"sourceType":"module"}