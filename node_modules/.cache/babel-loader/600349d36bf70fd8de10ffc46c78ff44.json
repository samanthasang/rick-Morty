{"ast":null,"code":"import React from 'react';\nimport { useToken } from '../theme/internal';\nexport const responsiveArray = ['xxl', 'xl', 'lg', 'md', 'sm', 'xs'];\n\nconst getResponsiveMap = token => ({\n  xs: `(max-width: ${token.screenXSMax}px)`,\n  sm: `(min-width: ${token.screenSM}px)`,\n  md: `(min-width: ${token.screenMD}px)`,\n  lg: `(min-width: ${token.screenLG}px)`,\n  xl: `(min-width: ${token.screenXL}px)`,\n  xxl: `(min-width: ${token.screenXXL}px)`\n});\n/**\n * Ensures that the breakpoints token are valid, in good order\n * For each breakpoint : screenMin <= screen <= screenMax and screenMax <= nextScreenMin\n */\n\n\nconst validateBreakpoints = token => {\n  const indexableToken = token;\n  const revBreakpoints = [].concat(responsiveArray).reverse();\n  revBreakpoints.forEach((breakpoint, i) => {\n    const breakpointUpper = breakpoint.toUpperCase();\n    const screenMin = `screen${breakpointUpper}Min`;\n    const screen = `screen${breakpointUpper}`;\n\n    if (!(indexableToken[screenMin] <= indexableToken[screen])) {\n      throw new Error(`${screenMin}<=${screen} fails : !(${indexableToken[screenMin]}<=${indexableToken[screen]})`);\n    }\n\n    if (i < revBreakpoints.length - 1) {\n      const screenMax = `screen${breakpointUpper}Max`;\n\n      if (!(indexableToken[screen] <= indexableToken[screenMax])) {\n        throw new Error(`${screen}<=${screenMax} fails : !(${indexableToken[screen]}<=${indexableToken[screenMax]})`);\n      }\n\n      const nextBreakpointUpperMin = revBreakpoints[i + 1].toUpperCase();\n      const nextScreenMin = `screen${nextBreakpointUpperMin}Min`;\n\n      if (!(indexableToken[screenMax] <= indexableToken[nextScreenMin])) {\n        throw new Error(`${screenMax}<=${nextScreenMin} fails : !(${indexableToken[screenMax]}<=${indexableToken[nextScreenMin]})`);\n      }\n    }\n  });\n  return token;\n};\n\nexport default function useResponsiveObserver() {\n  const [, token] = useToken();\n  const responsiveMap = getResponsiveMap(validateBreakpoints(token)); // To avoid repeat create instance, we add `useMemo` here.\n\n  return React.useMemo(() => {\n    const subscribers = new Map();\n    let subUid = -1;\n    let screens = {};\n    return {\n      matchHandlers: {},\n\n      dispatch(pointMap) {\n        screens = pointMap;\n        subscribers.forEach(func => func(screens));\n        return subscribers.size >= 1;\n      },\n\n      subscribe(func) {\n        if (!subscribers.size) this.register();\n        subUid += 1;\n        subscribers.set(subUid, func);\n        func(screens);\n        return subUid;\n      },\n\n      unsubscribe(paramToken) {\n        subscribers.delete(paramToken);\n        if (!subscribers.size) this.unregister();\n      },\n\n      unregister() {\n        Object.keys(responsiveMap).forEach(screen => {\n          const matchMediaQuery = responsiveMap[screen];\n          const handler = this.matchHandlers[matchMediaQuery];\n          handler === null || handler === void 0 ? void 0 : handler.mql.removeListener(handler === null || handler === void 0 ? void 0 : handler.listener);\n        });\n        subscribers.clear();\n      },\n\n      register() {\n        Object.keys(responsiveMap).forEach(screen => {\n          const matchMediaQuery = responsiveMap[screen];\n\n          const listener = _ref => {\n            let {\n              matches\n            } = _ref;\n            this.dispatch(Object.assign(Object.assign({}, screens), {\n              [screen]: matches\n            }));\n          };\n\n          const mql = window.matchMedia(matchMediaQuery);\n          mql.addListener(listener);\n          this.matchHandlers[matchMediaQuery] = {\n            mql,\n            listener\n          };\n          listener(mql);\n        });\n      },\n\n      responsiveMap\n    };\n  }, [token]);\n}","map":{"version":3,"sources":["/Users/luna/Desktop/Project/Git Project/rick-Morty/node_modules/antd/es/_util/responsiveObserver.js"],"names":["React","useToken","responsiveArray","getResponsiveMap","token","xs","screenXSMax","sm","screenSM","md","screenMD","lg","screenLG","xl","screenXL","xxl","screenXXL","validateBreakpoints","indexableToken","revBreakpoints","concat","reverse","forEach","breakpoint","i","breakpointUpper","toUpperCase","screenMin","screen","Error","length","screenMax","nextBreakpointUpperMin","nextScreenMin","useResponsiveObserver","responsiveMap","useMemo","subscribers","Map","subUid","screens","matchHandlers","dispatch","pointMap","func","size","subscribe","register","set","unsubscribe","paramToken","delete","unregister","Object","keys","matchMediaQuery","handler","mql","removeListener","listener","clear","_ref","matches","assign","window","matchMedia","addListener"],"mappings":"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","sourcesContent":["import React from 'react';\nimport { useToken } from '../theme/internal';\nexport const responsiveArray = ['xxl', 'xl', 'lg', 'md', 'sm', 'xs'];\nconst getResponsiveMap = token => ({\n  xs: `(max-width: ${token.screenXSMax}px)`,\n  sm: `(min-width: ${token.screenSM}px)`,\n  md: `(min-width: ${token.screenMD}px)`,\n  lg: `(min-width: ${token.screenLG}px)`,\n  xl: `(min-width: ${token.screenXL}px)`,\n  xxl: `(min-width: ${token.screenXXL}px)`\n});\n/**\n * Ensures that the breakpoints token are valid, in good order\n * For each breakpoint : screenMin <= screen <= screenMax and screenMax <= nextScreenMin\n */\nconst validateBreakpoints = token => {\n  const indexableToken = token;\n  const revBreakpoints = [].concat(responsiveArray).reverse();\n  revBreakpoints.forEach((breakpoint, i) => {\n    const breakpointUpper = breakpoint.toUpperCase();\n    const screenMin = `screen${breakpointUpper}Min`;\n    const screen = `screen${breakpointUpper}`;\n    if (!(indexableToken[screenMin] <= indexableToken[screen])) {\n      throw new Error(`${screenMin}<=${screen} fails : !(${indexableToken[screenMin]}<=${indexableToken[screen]})`);\n    }\n    if (i < revBreakpoints.length - 1) {\n      const screenMax = `screen${breakpointUpper}Max`;\n      if (!(indexableToken[screen] <= indexableToken[screenMax])) {\n        throw new Error(`${screen}<=${screenMax} fails : !(${indexableToken[screen]}<=${indexableToken[screenMax]})`);\n      }\n      const nextBreakpointUpperMin = revBreakpoints[i + 1].toUpperCase();\n      const nextScreenMin = `screen${nextBreakpointUpperMin}Min`;\n      if (!(indexableToken[screenMax] <= indexableToken[nextScreenMin])) {\n        throw new Error(`${screenMax}<=${nextScreenMin} fails : !(${indexableToken[screenMax]}<=${indexableToken[nextScreenMin]})`);\n      }\n    }\n  });\n  return token;\n};\nexport default function useResponsiveObserver() {\n  const [, token] = useToken();\n  const responsiveMap = getResponsiveMap(validateBreakpoints(token));\n  // To avoid repeat create instance, we add `useMemo` here.\n  return React.useMemo(() => {\n    const subscribers = new Map();\n    let subUid = -1;\n    let screens = {};\n    return {\n      matchHandlers: {},\n      dispatch(pointMap) {\n        screens = pointMap;\n        subscribers.forEach(func => func(screens));\n        return subscribers.size >= 1;\n      },\n      subscribe(func) {\n        if (!subscribers.size) this.register();\n        subUid += 1;\n        subscribers.set(subUid, func);\n        func(screens);\n        return subUid;\n      },\n      unsubscribe(paramToken) {\n        subscribers.delete(paramToken);\n        if (!subscribers.size) this.unregister();\n      },\n      unregister() {\n        Object.keys(responsiveMap).forEach(screen => {\n          const matchMediaQuery = responsiveMap[screen];\n          const handler = this.matchHandlers[matchMediaQuery];\n          handler === null || handler === void 0 ? void 0 : handler.mql.removeListener(handler === null || handler === void 0 ? void 0 : handler.listener);\n        });\n        subscribers.clear();\n      },\n      register() {\n        Object.keys(responsiveMap).forEach(screen => {\n          const matchMediaQuery = responsiveMap[screen];\n          const listener = _ref => {\n            let {\n              matches\n            } = _ref;\n            this.dispatch(Object.assign(Object.assign({}, screens), {\n              [screen]: matches\n            }));\n          };\n          const mql = window.matchMedia(matchMediaQuery);\n          mql.addListener(listener);\n          this.matchHandlers[matchMediaQuery] = {\n            mql,\n            listener\n          };\n          listener(mql);\n        });\n      },\n      responsiveMap\n    };\n  }, [token]);\n}"]},"metadata":{},"sourceType":"module"}