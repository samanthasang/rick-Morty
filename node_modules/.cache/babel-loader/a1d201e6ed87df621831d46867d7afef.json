{"ast":null,"code":"import _defineProperty from \"/Users/luna/Desktop/Project/Git Project/rick-Morty/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _slicedToArray from \"/Users/luna/Desktop/Project/Git Project/rick-Morty/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport React from 'react';\nimport { useToken } from '../theme/internal';\nexport var responsiveArray = ['xxl', 'xl', 'lg', 'md', 'sm', 'xs'];\n\nvar getResponsiveMap = function getResponsiveMap(token) {\n  return {\n    xs: \"(max-width: \".concat(token.screenXSMax, \"px)\"),\n    sm: \"(min-width: \".concat(token.screenSM, \"px)\"),\n    md: \"(min-width: \".concat(token.screenMD, \"px)\"),\n    lg: \"(min-width: \".concat(token.screenLG, \"px)\"),\n    xl: \"(min-width: \".concat(token.screenXL, \"px)\"),\n    xxl: \"(min-width: \".concat(token.screenXXL, \"px)\")\n  };\n};\n/**\n * Ensures that the breakpoints token are valid, in good order\n * For each breakpoint : screenMin <= screen <= screenMax and screenMax <= nextScreenMin\n */\n\n\nvar validateBreakpoints = function validateBreakpoints(token) {\n  var indexableToken = token;\n  var revBreakpoints = [].concat(responsiveArray).reverse();\n  revBreakpoints.forEach(function (breakpoint, i) {\n    var breakpointUpper = breakpoint.toUpperCase();\n    var screenMin = \"screen\".concat(breakpointUpper, \"Min\");\n    var screen = \"screen\".concat(breakpointUpper);\n\n    if (!(indexableToken[screenMin] <= indexableToken[screen])) {\n      throw new Error(\"\".concat(screenMin, \"<=\").concat(screen, \" fails : !(\").concat(indexableToken[screenMin], \"<=\").concat(indexableToken[screen], \")\"));\n    }\n\n    if (i < revBreakpoints.length - 1) {\n      var screenMax = \"screen\".concat(breakpointUpper, \"Max\");\n\n      if (!(indexableToken[screen] <= indexableToken[screenMax])) {\n        throw new Error(\"\".concat(screen, \"<=\").concat(screenMax, \" fails : !(\").concat(indexableToken[screen], \"<=\").concat(indexableToken[screenMax], \")\"));\n      }\n\n      var nextBreakpointUpperMin = revBreakpoints[i + 1].toUpperCase();\n      var nextScreenMin = \"screen\".concat(nextBreakpointUpperMin, \"Min\");\n\n      if (!(indexableToken[screenMax] <= indexableToken[nextScreenMin])) {\n        throw new Error(\"\".concat(screenMax, \"<=\").concat(nextScreenMin, \" fails : !(\").concat(indexableToken[screenMax], \"<=\").concat(indexableToken[nextScreenMin], \")\"));\n      }\n    }\n  });\n  return token;\n};\n\nexport default function useResponsiveObserver() {\n  var _useToken = useToken(),\n      _useToken2 = _slicedToArray(_useToken, 2),\n      token = _useToken2[1];\n\n  var responsiveMap = getResponsiveMap(validateBreakpoints(token)); // To avoid repeat create instance, we add `useMemo` here.\n\n  return React.useMemo(function () {\n    var subscribers = new Map();\n    var subUid = -1;\n    var screens = {};\n    return {\n      matchHandlers: {},\n      dispatch: function dispatch(pointMap) {\n        screens = pointMap;\n        subscribers.forEach(function (func) {\n          return func(screens);\n        });\n        return subscribers.size >= 1;\n      },\n      subscribe: function subscribe(func) {\n        if (!subscribers.size) this.register();\n        subUid += 1;\n        subscribers.set(subUid, func);\n        func(screens);\n        return subUid;\n      },\n      unsubscribe: function unsubscribe(paramToken) {\n        subscribers.delete(paramToken);\n        if (!subscribers.size) this.unregister();\n      },\n      unregister: function unregister() {\n        var _this = this;\n\n        Object.keys(responsiveMap).forEach(function (screen) {\n          var matchMediaQuery = responsiveMap[screen];\n          var handler = _this.matchHandlers[matchMediaQuery];\n          handler === null || handler === void 0 ? void 0 : handler.mql.removeListener(handler === null || handler === void 0 ? void 0 : handler.listener);\n        });\n        subscribers.clear();\n      },\n      register: function register() {\n        var _this2 = this;\n\n        Object.keys(responsiveMap).forEach(function (screen) {\n          var matchMediaQuery = responsiveMap[screen];\n\n          var listener = function listener(_ref) {\n            var matches = _ref.matches;\n\n            _this2.dispatch(Object.assign(Object.assign({}, screens), _defineProperty({}, screen, matches)));\n          };\n\n          var mql = window.matchMedia(matchMediaQuery);\n          mql.addListener(listener);\n          _this2.matchHandlers[matchMediaQuery] = {\n            mql: mql,\n            listener: listener\n          };\n          listener(mql);\n        });\n      },\n      responsiveMap: responsiveMap\n    };\n  }, [token]);\n}","map":{"version":3,"sources":["/Users/luna/Desktop/Project/Git Project/rick-Morty/node_modules/antd/es/_util/responsiveObserver.js"],"names":["React","useToken","responsiveArray","getResponsiveMap","token","xs","screenXSMax","sm","screenSM","md","screenMD","lg","screenLG","xl","screenXL","xxl","screenXXL","validateBreakpoints","indexableToken","revBreakpoints","concat","reverse","forEach","breakpoint","i","breakpointUpper","toUpperCase","screenMin","screen","Error","length","screenMax","nextBreakpointUpperMin","nextScreenMin","useResponsiveObserver","responsiveMap","useMemo","subscribers","Map","subUid","screens","matchHandlers","dispatch","pointMap","func","size","subscribe","register","set","unsubscribe","paramToken","delete","unregister","Object","keys","matchMediaQuery","handler","mql","removeListener","listener","clear","_ref","matches","assign","window","matchMedia","addListener"],"mappings":";;AAAA,OAAOA,KAAP,MAAkB,OAAlB;AACA,SAASC,QAAT,QAAyB,mBAAzB;AACA,OAAO,IAAMC,eAAe,GAAG,CAAC,KAAD,EAAQ,IAAR,EAAc,IAAd,EAAoB,IAApB,EAA0B,IAA1B,EAAgC,IAAhC,CAAxB;;AACP,IAAMC,gBAAgB,GAAG,SAAnBA,gBAAmB,CAAAC,KAAK;AAAA,SAAK;AACjCC,IAAAA,EAAE,wBAAiBD,KAAK,CAACE,WAAvB,QAD+B;AAEjCC,IAAAA,EAAE,wBAAiBH,KAAK,CAACI,QAAvB,QAF+B;AAGjCC,IAAAA,EAAE,wBAAiBL,KAAK,CAACM,QAAvB,QAH+B;AAIjCC,IAAAA,EAAE,wBAAiBP,KAAK,CAACQ,QAAvB,QAJ+B;AAKjCC,IAAAA,EAAE,wBAAiBT,KAAK,CAACU,QAAvB,QAL+B;AAMjCC,IAAAA,GAAG,wBAAiBX,KAAK,CAACY,SAAvB;AAN8B,GAAL;AAAA,CAA9B;AAQA;AACA;AACA;AACA;;;AACA,IAAMC,mBAAmB,GAAG,SAAtBA,mBAAsB,CAAAb,KAAK,EAAI;AACnC,MAAMc,cAAc,GAAGd,KAAvB;AACA,MAAMe,cAAc,GAAG,GAAGC,MAAH,CAAUlB,eAAV,EAA2BmB,OAA3B,EAAvB;AACAF,EAAAA,cAAc,CAACG,OAAf,CAAuB,UAACC,UAAD,EAAaC,CAAb,EAAmB;AACxC,QAAMC,eAAe,GAAGF,UAAU,CAACG,WAAX,EAAxB;AACA,QAAMC,SAAS,mBAAYF,eAAZ,QAAf;AACA,QAAMG,MAAM,mBAAYH,eAAZ,CAAZ;;AACA,QAAI,EAAEP,cAAc,CAACS,SAAD,CAAd,IAA6BT,cAAc,CAACU,MAAD,CAA7C,CAAJ,EAA4D;AAC1D,YAAM,IAAIC,KAAJ,WAAaF,SAAb,eAA2BC,MAA3B,wBAA+CV,cAAc,CAACS,SAAD,CAA7D,eAA6ET,cAAc,CAACU,MAAD,CAA3F,OAAN;AACD;;AACD,QAAIJ,CAAC,GAAGL,cAAc,CAACW,MAAf,GAAwB,CAAhC,EAAmC;AACjC,UAAMC,SAAS,mBAAYN,eAAZ,QAAf;;AACA,UAAI,EAAEP,cAAc,CAACU,MAAD,CAAd,IAA0BV,cAAc,CAACa,SAAD,CAA1C,CAAJ,EAA4D;AAC1D,cAAM,IAAIF,KAAJ,WAAaD,MAAb,eAAwBG,SAAxB,wBAA+Cb,cAAc,CAACU,MAAD,CAA7D,eAA0EV,cAAc,CAACa,SAAD,CAAxF,OAAN;AACD;;AACD,UAAMC,sBAAsB,GAAGb,cAAc,CAACK,CAAC,GAAG,CAAL,CAAd,CAAsBE,WAAtB,EAA/B;AACA,UAAMO,aAAa,mBAAYD,sBAAZ,QAAnB;;AACA,UAAI,EAAEd,cAAc,CAACa,SAAD,CAAd,IAA6Bb,cAAc,CAACe,aAAD,CAA7C,CAAJ,EAAmE;AACjE,cAAM,IAAIJ,KAAJ,WAAaE,SAAb,eAA2BE,aAA3B,wBAAsDf,cAAc,CAACa,SAAD,CAApE,eAAoFb,cAAc,CAACe,aAAD,CAAlG,OAAN;AACD;AACF;AACF,GAlBD;AAmBA,SAAO7B,KAAP;AACD,CAvBD;;AAwBA,eAAe,SAAS8B,qBAAT,GAAiC;AAC9C,kBAAkBjC,QAAQ,EAA1B;AAAA;AAAA,MAASG,KAAT;;AACA,MAAM+B,aAAa,GAAGhC,gBAAgB,CAACc,mBAAmB,CAACb,KAAD,CAApB,CAAtC,CAF8C,CAG9C;;AACA,SAAOJ,KAAK,CAACoC,OAAN,CAAc,YAAM;AACzB,QAAMC,WAAW,GAAG,IAAIC,GAAJ,EAApB;AACA,QAAIC,MAAM,GAAG,CAAC,CAAd;AACA,QAAIC,OAAO,GAAG,EAAd;AACA,WAAO;AACLC,MAAAA,aAAa,EAAE,EADV;AAELC,MAAAA,QAFK,oBAEIC,QAFJ,EAEc;AACjBH,QAAAA,OAAO,GAAGG,QAAV;AACAN,QAAAA,WAAW,CAACf,OAAZ,CAAoB,UAAAsB,IAAI;AAAA,iBAAIA,IAAI,CAACJ,OAAD,CAAR;AAAA,SAAxB;AACA,eAAOH,WAAW,CAACQ,IAAZ,IAAoB,CAA3B;AACD,OANI;AAOLC,MAAAA,SAPK,qBAOKF,IAPL,EAOW;AACd,YAAI,CAACP,WAAW,CAACQ,IAAjB,EAAuB,KAAKE,QAAL;AACvBR,QAAAA,MAAM,IAAI,CAAV;AACAF,QAAAA,WAAW,CAACW,GAAZ,CAAgBT,MAAhB,EAAwBK,IAAxB;AACAA,QAAAA,IAAI,CAACJ,OAAD,CAAJ;AACA,eAAOD,MAAP;AACD,OAbI;AAcLU,MAAAA,WAdK,uBAcOC,UAdP,EAcmB;AACtBb,QAAAA,WAAW,CAACc,MAAZ,CAAmBD,UAAnB;AACA,YAAI,CAACb,WAAW,CAACQ,IAAjB,EAAuB,KAAKO,UAAL;AACxB,OAjBI;AAkBLA,MAAAA,UAlBK,wBAkBQ;AAAA;;AACXC,QAAAA,MAAM,CAACC,IAAP,CAAYnB,aAAZ,EAA2Bb,OAA3B,CAAmC,UAAAM,MAAM,EAAI;AAC3C,cAAM2B,eAAe,GAAGpB,aAAa,CAACP,MAAD,CAArC;AACA,cAAM4B,OAAO,GAAG,KAAI,CAACf,aAAL,CAAmBc,eAAnB,CAAhB;AACAC,UAAAA,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyC,KAAK,CAA9C,GAAkDA,OAAO,CAACC,GAAR,CAAYC,cAAZ,CAA2BF,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyC,KAAK,CAA9C,GAAkDA,OAAO,CAACG,QAArF,CAAlD;AACD,SAJD;AAKAtB,QAAAA,WAAW,CAACuB,KAAZ;AACD,OAzBI;AA0BLb,MAAAA,QA1BK,sBA0BM;AAAA;;AACTM,QAAAA,MAAM,CAACC,IAAP,CAAYnB,aAAZ,EAA2Bb,OAA3B,CAAmC,UAAAM,MAAM,EAAI;AAC3C,cAAM2B,eAAe,GAAGpB,aAAa,CAACP,MAAD,CAArC;;AACA,cAAM+B,QAAQ,GAAG,SAAXA,QAAW,CAAAE,IAAI,EAAI;AACvB,gBACEC,OADF,GAEID,IAFJ,CACEC,OADF;;AAGA,YAAA,MAAI,CAACpB,QAAL,CAAcW,MAAM,CAACU,MAAP,CAAcV,MAAM,CAACU,MAAP,CAAc,EAAd,EAAkBvB,OAAlB,CAAd,sBACXZ,MADW,EACFkC,OADE,EAAd;AAGD,WAPD;;AAQA,cAAML,GAAG,GAAGO,MAAM,CAACC,UAAP,CAAkBV,eAAlB,CAAZ;AACAE,UAAAA,GAAG,CAACS,WAAJ,CAAgBP,QAAhB;AACA,UAAA,MAAI,CAAClB,aAAL,CAAmBc,eAAnB,IAAsC;AACpCE,YAAAA,GAAG,EAAHA,GADoC;AAEpCE,YAAAA,QAAQ,EAARA;AAFoC,WAAtC;AAIAA,UAAAA,QAAQ,CAACF,GAAD,CAAR;AACD,SAjBD;AAkBD,OA7CI;AA8CLtB,MAAAA,aAAa,EAAbA;AA9CK,KAAP;AAgDD,GApDM,EAoDJ,CAAC/B,KAAD,CApDI,CAAP;AAqDD","sourcesContent":["import React from 'react';\nimport { useToken } from '../theme/internal';\nexport const responsiveArray = ['xxl', 'xl', 'lg', 'md', 'sm', 'xs'];\nconst getResponsiveMap = token => ({\n  xs: `(max-width: ${token.screenXSMax}px)`,\n  sm: `(min-width: ${token.screenSM}px)`,\n  md: `(min-width: ${token.screenMD}px)`,\n  lg: `(min-width: ${token.screenLG}px)`,\n  xl: `(min-width: ${token.screenXL}px)`,\n  xxl: `(min-width: ${token.screenXXL}px)`\n});\n/**\n * Ensures that the breakpoints token are valid, in good order\n * For each breakpoint : screenMin <= screen <= screenMax and screenMax <= nextScreenMin\n */\nconst validateBreakpoints = token => {\n  const indexableToken = token;\n  const revBreakpoints = [].concat(responsiveArray).reverse();\n  revBreakpoints.forEach((breakpoint, i) => {\n    const breakpointUpper = breakpoint.toUpperCase();\n    const screenMin = `screen${breakpointUpper}Min`;\n    const screen = `screen${breakpointUpper}`;\n    if (!(indexableToken[screenMin] <= indexableToken[screen])) {\n      throw new Error(`${screenMin}<=${screen} fails : !(${indexableToken[screenMin]}<=${indexableToken[screen]})`);\n    }\n    if (i < revBreakpoints.length - 1) {\n      const screenMax = `screen${breakpointUpper}Max`;\n      if (!(indexableToken[screen] <= indexableToken[screenMax])) {\n        throw new Error(`${screen}<=${screenMax} fails : !(${indexableToken[screen]}<=${indexableToken[screenMax]})`);\n      }\n      const nextBreakpointUpperMin = revBreakpoints[i + 1].toUpperCase();\n      const nextScreenMin = `screen${nextBreakpointUpperMin}Min`;\n      if (!(indexableToken[screenMax] <= indexableToken[nextScreenMin])) {\n        throw new Error(`${screenMax}<=${nextScreenMin} fails : !(${indexableToken[screenMax]}<=${indexableToken[nextScreenMin]})`);\n      }\n    }\n  });\n  return token;\n};\nexport default function useResponsiveObserver() {\n  const [, token] = useToken();\n  const responsiveMap = getResponsiveMap(validateBreakpoints(token));\n  // To avoid repeat create instance, we add `useMemo` here.\n  return React.useMemo(() => {\n    const subscribers = new Map();\n    let subUid = -1;\n    let screens = {};\n    return {\n      matchHandlers: {},\n      dispatch(pointMap) {\n        screens = pointMap;\n        subscribers.forEach(func => func(screens));\n        return subscribers.size >= 1;\n      },\n      subscribe(func) {\n        if (!subscribers.size) this.register();\n        subUid += 1;\n        subscribers.set(subUid, func);\n        func(screens);\n        return subUid;\n      },\n      unsubscribe(paramToken) {\n        subscribers.delete(paramToken);\n        if (!subscribers.size) this.unregister();\n      },\n      unregister() {\n        Object.keys(responsiveMap).forEach(screen => {\n          const matchMediaQuery = responsiveMap[screen];\n          const handler = this.matchHandlers[matchMediaQuery];\n          handler === null || handler === void 0 ? void 0 : handler.mql.removeListener(handler === null || handler === void 0 ? void 0 : handler.listener);\n        });\n        subscribers.clear();\n      },\n      register() {\n        Object.keys(responsiveMap).forEach(screen => {\n          const matchMediaQuery = responsiveMap[screen];\n          const listener = _ref => {\n            let {\n              matches\n            } = _ref;\n            this.dispatch(Object.assign(Object.assign({}, screens), {\n              [screen]: matches\n            }));\n          };\n          const mql = window.matchMedia(matchMediaQuery);\n          mql.addListener(listener);\n          this.matchHandlers[matchMediaQuery] = {\n            mql,\n            listener\n          };\n          listener(mql);\n        });\n      },\n      responsiveMap\n    };\n  }, [token]);\n}"]},"metadata":{},"sourceType":"module"}