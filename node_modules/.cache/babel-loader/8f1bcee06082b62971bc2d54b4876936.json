{"ast":null,"code":"import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport { useState, useRef } from 'react';\nimport raf from \"rc-util/es/raf\";\nimport { getClientSize } from \"rc-util/es/Dom/css\";\nimport { MIN_SCALE, MAX_SCALE } from \"../previewConfig\";\nvar initialTransform = {\n  x: 0,\n  y: 0,\n  rotate: 0,\n  scale: 1,\n  flipX: false,\n  flipY: false\n};\nexport default function useImageTransform(imgRef) {\n  var frame = useRef(null);\n  var queue = useRef([]);\n\n  var _useState = useState(initialTransform),\n      _useState2 = _slicedToArray(_useState, 2),\n      transform = _useState2[0],\n      setTransform = _useState2[1];\n\n  var resetTransform = function resetTransform() {\n    setTransform(initialTransform);\n  };\n  /** Direct update transform */\n\n\n  var updateTransform = function updateTransform(newTransform) {\n    if (frame.current === null) {\n      queue.current = [];\n      frame.current = raf(function () {\n        setTransform(function (preState) {\n          var memoState = preState;\n          queue.current.forEach(function (queueState) {\n            memoState = _objectSpread(_objectSpread({}, memoState), queueState);\n          });\n          frame.current = null;\n          return memoState;\n        });\n      });\n    }\n\n    queue.current.push(_objectSpread(_objectSpread({}, transform), newTransform));\n  };\n  /** Scale according to the position of clientX and clientY */\n\n\n  var dispatchZoomChange = function dispatchZoomChange(ratio, clientX, clientY) {\n    var _imgRef$current = imgRef.current,\n        width = _imgRef$current.width,\n        height = _imgRef$current.height,\n        offsetWidth = _imgRef$current.offsetWidth,\n        offsetHeight = _imgRef$current.offsetHeight,\n        offsetLeft = _imgRef$current.offsetLeft,\n        offsetTop = _imgRef$current.offsetTop;\n    var newRatio = ratio;\n    var newScale = transform.scale * ratio;\n\n    if (newScale > MAX_SCALE) {\n      newRatio = MAX_SCALE / transform.scale;\n      newScale = MAX_SCALE;\n    } else if (newScale < MIN_SCALE) {\n      newRatio = MIN_SCALE / transform.scale;\n      newScale = MIN_SCALE;\n    }\n    /** Default center point scaling */\n\n\n    var mergedClientX = clientX !== null && clientX !== void 0 ? clientX : innerWidth / 2;\n    var mergedClientY = clientY !== null && clientY !== void 0 ? clientY : innerHeight / 2;\n    var diffRatio = newRatio - 1;\n    /** Deviation calculated from image size */\n\n    var diffImgX = diffRatio * width * 0.5;\n    var diffImgY = diffRatio * height * 0.5;\n    /** The difference between the click position and the edge of the document */\n\n    var diffOffsetLeft = diffRatio * (mergedClientX - transform.x - offsetLeft);\n    var diffOffsetTop = diffRatio * (mergedClientY - transform.y - offsetTop);\n    /** Final positioning */\n\n    var newX = transform.x - (diffOffsetLeft - diffImgX);\n    var newY = transform.y - (diffOffsetTop - diffImgY);\n    /**\n     * When zooming the image\n     * When the image size is smaller than the width and height of the window, the position is initialized\n     */\n\n    if (ratio < 1 && newScale === 1) {\n      var mergedWidth = offsetWidth * newScale;\n      var mergedHeight = offsetHeight * newScale;\n\n      var _getClientSize = getClientSize(),\n          clientWidth = _getClientSize.width,\n          clientHeight = _getClientSize.height;\n\n      if (mergedWidth <= clientWidth && mergedHeight <= clientHeight) {\n        newX = 0;\n        newY = 0;\n      }\n    }\n\n    updateTransform({\n      x: newX,\n      y: newY,\n      scale: newScale\n    });\n  };\n\n  return {\n    transform: transform,\n    resetTransform: resetTransform,\n    updateTransform: updateTransform,\n    dispatchZoomChange: dispatchZoomChange\n  };\n}\n;","map":{"version":3,"sources":["/Users/luna/Desktop/Project/Git Project/rick-Morty/node_modules/rc-image/es/hooks/useImageTransform.js"],"names":["_objectSpread","_slicedToArray","useState","useRef","raf","getClientSize","MIN_SCALE","MAX_SCALE","initialTransform","x","y","rotate","scale","flipX","flipY","useImageTransform","imgRef","frame","queue","_useState","_useState2","transform","setTransform","resetTransform","updateTransform","newTransform","current","preState","memoState","forEach","queueState","push","dispatchZoomChange","ratio","clientX","clientY","_imgRef$current","width","height","offsetWidth","offsetHeight","offsetLeft","offsetTop","newRatio","newScale","mergedClientX","innerWidth","mergedClientY","innerHeight","diffRatio","diffImgX","diffImgY","diffOffsetLeft","diffOffsetTop","newX","newY","mergedWidth","mergedHeight","_getClientSize","clientWidth","clientHeight"],"mappings":"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","sourcesContent":["import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread2\";\nimport _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport { useState, useRef } from 'react';\nimport raf from \"rc-util/es/raf\";\nimport { getClientSize } from \"rc-util/es/Dom/css\";\nimport { MIN_SCALE, MAX_SCALE } from \"../previewConfig\";\nvar initialTransform = {\n  x: 0,\n  y: 0,\n  rotate: 0,\n  scale: 1,\n  flipX: false,\n  flipY: false\n};\nexport default function useImageTransform(imgRef) {\n  var frame = useRef(null);\n  var queue = useRef([]);\n  var _useState = useState(initialTransform),\n    _useState2 = _slicedToArray(_useState, 2),\n    transform = _useState2[0],\n    setTransform = _useState2[1];\n  var resetTransform = function resetTransform() {\n    setTransform(initialTransform);\n  };\n\n  /** Direct update transform */\n  var updateTransform = function updateTransform(newTransform) {\n    if (frame.current === null) {\n      queue.current = [];\n      frame.current = raf(function () {\n        setTransform(function (preState) {\n          var memoState = preState;\n          queue.current.forEach(function (queueState) {\n            memoState = _objectSpread(_objectSpread({}, memoState), queueState);\n          });\n          frame.current = null;\n          return memoState;\n        });\n      });\n    }\n    queue.current.push(_objectSpread(_objectSpread({}, transform), newTransform));\n  };\n\n  /** Scale according to the position of clientX and clientY */\n  var dispatchZoomChange = function dispatchZoomChange(ratio, clientX, clientY) {\n    var _imgRef$current = imgRef.current,\n      width = _imgRef$current.width,\n      height = _imgRef$current.height,\n      offsetWidth = _imgRef$current.offsetWidth,\n      offsetHeight = _imgRef$current.offsetHeight,\n      offsetLeft = _imgRef$current.offsetLeft,\n      offsetTop = _imgRef$current.offsetTop;\n    var newRatio = ratio;\n    var newScale = transform.scale * ratio;\n    if (newScale > MAX_SCALE) {\n      newRatio = MAX_SCALE / transform.scale;\n      newScale = MAX_SCALE;\n    } else if (newScale < MIN_SCALE) {\n      newRatio = MIN_SCALE / transform.scale;\n      newScale = MIN_SCALE;\n    }\n\n    /** Default center point scaling */\n    var mergedClientX = clientX !== null && clientX !== void 0 ? clientX : innerWidth / 2;\n    var mergedClientY = clientY !== null && clientY !== void 0 ? clientY : innerHeight / 2;\n    var diffRatio = newRatio - 1;\n    /** Deviation calculated from image size */\n    var diffImgX = diffRatio * width * 0.5;\n    var diffImgY = diffRatio * height * 0.5;\n    /** The difference between the click position and the edge of the document */\n    var diffOffsetLeft = diffRatio * (mergedClientX - transform.x - offsetLeft);\n    var diffOffsetTop = diffRatio * (mergedClientY - transform.y - offsetTop);\n    /** Final positioning */\n    var newX = transform.x - (diffOffsetLeft - diffImgX);\n    var newY = transform.y - (diffOffsetTop - diffImgY);\n\n    /**\n     * When zooming the image\n     * When the image size is smaller than the width and height of the window, the position is initialized\n     */\n    if (ratio < 1 && newScale === 1) {\n      var mergedWidth = offsetWidth * newScale;\n      var mergedHeight = offsetHeight * newScale;\n      var _getClientSize = getClientSize(),\n        clientWidth = _getClientSize.width,\n        clientHeight = _getClientSize.height;\n      if (mergedWidth <= clientWidth && mergedHeight <= clientHeight) {\n        newX = 0;\n        newY = 0;\n      }\n    }\n    updateTransform({\n      x: newX,\n      y: newY,\n      scale: newScale\n    });\n  };\n  return {\n    transform: transform,\n    resetTransform: resetTransform,\n    updateTransform: updateTransform,\n    dispatchZoomChange: dispatchZoomChange\n  };\n}\n;"]},"metadata":{},"sourceType":"module"}